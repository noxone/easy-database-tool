<?xml version="1.0" encoding="UTF-8"?>
<EdtHelp version="1">
	<ReturnCodes>
		<code>000</code>
		<message><![CDATA[SUCCESSFUL EXECUTION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[]]></programmersResponse>
		<sqlState>00000 for unqualified successful execution
01ddd for successful execution with warning 'ddd'.</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+012</code>
		<message><![CDATA[THE UNQUALIFIED COLUMN NAME column-name WAS INTERPRETED AS A CORRELATED REFERENCE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If DB2's interpretation of the column name was not what you intended, rewrite the SQL statement and submit it again. If you intend the column name to refer to a table named at a higher level, we advise rewriting the statement anyway, using a table name or correlation name as a qualifier for the column name. The unqualified column name could be interpreted differently if you do a rebind after altering one of the tables to which you refer.]]></programmersResponse>
		<sqlState>01545</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+098</code>
		<message><![CDATA[A DYNAMIC SQL STATEMENT ENDS WITH A SEMICOLON.]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Check that the semicolon is being used as a statement terminator.]]></programmersResponse>
		<sqlState>01568</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+100</code>
		<message><![CDATA[ROW NOT FOUND FOR FETCH, UPDATE OR DELETE, OR THE RESULT OF A QUERY IS AN EMPTY TABLE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[]]></programmersResponse>
		<sqlState>02000</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+110</code>
		<message><![CDATA[SQL UPDATE TO A DATA CAPTURE TABLE NOT SIGNALED TO ORIGINATING SUBSYSTEM]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[]]></programmersResponse>
		<sqlState>01561</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+111</code>
		<message><![CDATA[THE SUBPAGES OPTION IS NOT SUPPORTED FOR TYPE 2 INDEXES]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Remove the SUBPAGES option to get rid of the warning.]]></programmersResponse>
		<sqlState>01590</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+117</code>
		<message><![CDATA[THE NUMBER OF INSERT VALUES IS NOT THE SAME AS THE NUMBER OF OBJECT COLUMNS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[For better performance, rebind the plan or package after correcting the statement. To correct the statement, specify one and only one value for each of the specified object columns.]]></programmersResponse>
		<sqlState>01525</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+162</code>
		<message><![CDATA[TABLESPACE database-name.tablespace-name HAS BEEN PLACED IN CHECK PENDING]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Run the CHECK DATA utility. The enforcement of the referential constraint or the check constraint is deferred until the CHECK DATA utility is run.]]></programmersResponse>
		<sqlState>01514</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+203</code>
		<message><![CDATA[THE QUALIFIED COLUMN NAME column-name WAS RESOLVED USING A NON-UNIQUE OR UNEXPOSED NAME]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If DB2's resolution of the qualifier was not what you intended, rewrite the SQL statement and submit it again. The rules used to resolve column name qualifiers are given in Chapter 2 of DB2 SQL Reference.]]></programmersResponse>
		<sqlState>01552</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+204</code>
		<message><![CDATA[name IS AN UNDEFINED NAME]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[For better performance, rebind the plan or package after correcting the statement. To correct the statement, determine that the object name was correctly specified in the SQL statement (including any required qualifiers). If so, ensure that the object exists in the system before resubmitting the statement.]]></programmersResponse>
		<sqlState>01532</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+206</code>
		<message><![CDATA[column-name IS NOT A COLUMN OF AN INSERTED TABLE, UPDATED TABLE, OR ANY TABLE IDENTIFIED IN A FROM CLAUSE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[For better performance, rebind the plan or package after correcting the statement. To correct the statement, verify that the column and table names are specified correctly in the SQL statement. In the case of a SELECT statement, check to be sure that all of the required tables were named in the FROM clause.]]></programmersResponse>
		<sqlState>01533</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+218</code>
		<message><![CDATA[THE SQL STATEMENT REFERENCING A REMOTE OBJECT CANNOT BE EXPLAINED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[]]></programmersResponse>
		<sqlState>01537</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+219</code>
		<message><![CDATA[THE REQUIRED EXPLANATION TABLE table-name DOES NOT EXIST]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[For better performance, rebind the plan or package after correcting the statement. To correct the statement, determine whether the required explanation table does exist. If not, create the required table.]]></programmersResponse>
		<sqlState>01532</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+220</code>
		<message><![CDATA[THE COLUMN column-name IN EXPLANATION TABLE table-name IS NOT DEFINED PROPERLY]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[For better performance, rebind the plan or package after correcting the statement. To correct the statement, correct the definition of the required explanation table. Refer to Chapter 5 of DB2 SQL Reference for information about defining an explanation table.]]></programmersResponse>
		<sqlState>01546</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+222</code>
		<message><![CDATA[HOLE DETECTED USING CURSOR cursor-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the application program to handle this situation, or change isolation levels so the base row cannot be deleted during the cursor operation.]]></programmersResponse>
		<sqlState>02502</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+231</code>
		<message><![CDATA[CURRENT POSITION OF CURSOR cursor-name IS NOT VALID FOR FETCH OF THE CURRENT ROW]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the application program to establish position before issuing this FETCH statement.]]></programmersResponse>
		<sqlState>02000</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+236</code>
		<message><![CDATA[SQLDA INCLUDES integer1 SQLVAR ENTRIES, BUT integer2 ARE REQUIRED FOR integer3 COLUMNS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Increase the value of the SQLN field in the SQLDA to the value indicated in the message (making sure the SQLDA is large enough to support that amount) and resubmit the statement.]]></programmersResponse>
		<sqlState>01005</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+237</code>
		<message><![CDATA[SQLDA INCLUDES integer1 SQLVAR ENTRIES, BUT integer2 ARE REQUIRED BECAUSE AT LEAST ONE OF THE COLUMNS BEING DESCRIBED IS A DISTINCT TYPE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If there is no need for the additional information about the distinct type(s), then no action is required unless USING BOTH was specified (in which case additional SQLVAR entries must be provided for the labels).
If the distinct type information is needed, the value of the SQLN field in the SQLDA should be increased to integer2 (after making sure that the SQLDA is large enough to support that amount) and the statement should be resubmitted.]]></programmersResponse>
		<sqlState>01594</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+238</code>
		<message><![CDATA[SQLDA INCLUDES integer1 SQLVAR ENTRIES, BUT integer2 SQLVAR ENTRIES ARE NEEDED FOR integer3 COLUMNS BECAUSE AT LEAST ONE OF THE COLUMNS BEING DESCRIBED IS A LOB]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Increase the value of the SQLN field in the SQLDA to integer2 (after making sure that the SQLDA is large enough to support that amount) and resubmit the statement.]]></programmersResponse>
		<sqlState>01005</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+239</code>
		<message><![CDATA[SQLDA INCLUDES integer1 SQLVAR ENTRIES, BUT integer2 ARE REQUIRED FOR integer3 COLUMNS BECAUSE AT LEAST ONE OF THE COLUMNS BEING DESCRIBED IS A DISTINCT TYPE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If the distinct type information is needed, the value of the SQLN field in the SQLDA should be increased to integer2 (after making sure the SQLDA is large enough to support that amount) and the statement should be resubmitted.
If there is no need for the additional information about the distinct type(s) in the result set, then it is possible to resubmit the statement only providing enough SQLVAR entries to accommodate the number of columns being described (i.e. provide the necessary number of base SQL entries).]]></programmersResponse>
		<sqlState>01005</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+252</code>
		<message><![CDATA[A NON-ATOMIC statement STATEMENT SUCCESSFULLY PROCESSED ALL REQUESTED ROWS, WITH ONE OR MORE WARNING CONDITIONS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Analyze the warning conditions to determine whether the statement should be rolled back or not.]]></programmersResponse>
		<sqlState>01659</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+304</code>
		<message><![CDATA[A VALUE WITH DATA TYPE data-type1 CANNOT BE ASSIGNED TO A HOST VARIABLE BECAUSE THE VALUE IS NOT WITHIN THE RANGE OF THE HOST VARIABLE IN POSITION position-number WITH DATA TYPE data-type2]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify that table definitions are current, and that the host variable has the proper data type. See the explanation for SQLCODE -405 for ranges of SQL data types.]]></programmersResponse>
		<sqlState>01515</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+331</code>
		<message><![CDATA[THE NULL VALUE HAS BEEN ASSIGNED TO A HOST VARIABLE OR PARAMETER BECAUSE THE STRING CANNOT BE CONVERTED FROM source-ccsid TO target-ccsid. REASON reason-code, POSITION position-number]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[]]></programmersResponse>
		<sqlState>01520</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+335</code>
		<message><![CDATA[DB2 CONVERTED A HOST VARIABLE, PARAMETER, OR COLUMN NUMBER var-num var-name-or-num TO COLUMN NAME, HOST VARIABLE, OR EXPRESSION NUMBER col-name-or-num FROM from ccsid TO to-ccsid, AND RESULTING IN SUBSTITUTION CHARACTERS.]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[This warning can occur in two situations:
 - If trace for IFCID 136 or 168 is not active, DB2 processes the SQL statement, but used substitution characters instead one or more characters as a result of character conversion from from ccsid to to-ccsid. If substitution is acceptable, no action is necessary. If substitution is not acceptable, issue a ROLLBACK. Ensure that data being provided to DB2 is convertible from from ccsid to to-ccsid without data loss.
 - If trace for IFCID 136 or 168 is active, and the to-ccsid token is an EBCDIC CCSID, and system parameter UIFCIDS is OFF, then this warning is caused by the conversion to EBCDIC CCSID for IFCID trace record. Use GET DIAGNOSTICS to determine if the orignal SQL string had any other warnings associated with it. If GET DIAGNOSTICS returns no other warnings, no action is required.]]></programmersResponse>
		<sqlState>01517</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+347</code>
		<message><![CDATA[THE RECURSIVE COMMON TABLE EXPRESSION name MAY CONTAIN AN INFINITE LOOP]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[To prevent an infinite loop, include the expected syntax as described.]]></programmersResponse>
		<sqlState>01605</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+394</code>
		<message><![CDATA[USER SPECIFIED OPTIMIZATION HINTS USED DURING ACCESS PATH SELECTION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure that the access path is correct and produces the correct results.]]></programmersResponse>
		<sqlState>01629</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+395</code>
		<message><![CDATA[USER SPECIFIED OPTIMIZATION HINTS ARE INVALID (REASON CODE = reason-code). THE OPTIMIZATION HINTS ARE IGNORED.]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the problem with the optimization hints, or disable their use for this query.]]></programmersResponse>
		<sqlState>01628</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+402</code>
		<message><![CDATA[LOCATION location IS UNKNOWN]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[]]></programmersResponse>
		<sqlState>01521</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+403</code>
		<message><![CDATA[THE LOCAL OBJECT REFERENCED BY THE CREATE ALIAS STATEMENT DOES NOT EXIST]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[]]></programmersResponse>
		<sqlState>01522</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+434</code>
		<message><![CDATA[OPTION keyword IS A DEPRECATED FEATURE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[No change is required for the current release. However, you should change your SQL statement and remove this feature to prepare for future releases when this feature is not supported.]]></programmersResponse>
		<sqlState>01608</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+445</code>
		<message><![CDATA[VALUE value HAS BEEN TRUNCATED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure that the output is as expected and that the truncation has not caused any unexpected consequences.]]></programmersResponse>
		<sqlState>01004</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+462</code>
		<message><![CDATA[EXTERNAL FUNCTION OR PROCEDURE name (SPECIFIC NAME specific-name) HAS RETURNED A WARNING SQLSTATE, WITH DIAGNOSTIC TEXT text]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[See your database administrator, or the author of the function or procedure to find out the meaning of the warning. The significance of the bad SQLSTATE to the invoking application can be learned from the author of the function or procedure.]]></programmersResponse>
		<sqlState>01Hxx</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+464</code>
		<message><![CDATA[PROCEDURE proc RETURNED num QUERY RESULT SETS, WHICH EXCEEDS THE DEFINED LIMIT integer]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[]]></programmersResponse>
		<sqlState>0100E</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+466</code>
		<message><![CDATA[PROCEDURE proc RETURNED num QUERY RESULTS SETS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[]]></programmersResponse>
		<sqlState>0100C</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+494</code>
		<message><![CDATA[NUMBER OF RESULT SETS IS GREATER THAN NUMBER OF LOCATORS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Increase the number of result set locator variables specified on the SQL statement.]]></programmersResponse>
		<sqlState>01614</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+495</code>
		<message><![CDATA[ESTIMATED PROCESSOR COST OF estimate-amount1 PROCESSOR SECONDS (estimate-amount2 SERVICE UNITS) IN COST CATEGORY cost-category EXCEEDS A RESOURCE LIMIT WARNING THRESHOLD OF limit- amount SERVICE UNITS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure that there is application logic to handle the warning to either allow the statement to execute or to stop the statement from being executed. If this SQLCODE was returned because the cost category value is &quot;B,&quot; it might be that the statement is using parameter markers or that some statistics are not available for the referenced tables and columns. Make sure the administrator has run the utility RUNSTATS on the referenced tables. It might also be that UDFs will be invoked when the statement is executed, or for INSERT, UPDATE, or DELETE statements that triggers are defined on the changed table. Check the DSN_STATEMNT_TABLE or the IFCID 22 record for this statement to find the reasons this SQL statement has been put in cost category &quot;B.&quot;
If the warning is caused by an SQL statement that is consuming too much processor resource, attempt to rewrite the statement to perform more efficiently. Another option is to ask the administrator to increase the warning threshold value in the RLST.]]></programmersResponse>
		<sqlState>01616</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+535</code>
		<message><![CDATA[THE RESULT OF THE POSITIONED UPDATE OR DELETE MAY DEPEND ON THE ORDER OF THE ROWS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[]]></programmersResponse>
		<sqlState>01591</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+541</code>
		<message><![CDATA[THE REFERENTIAL OR UNIQUE CONSTRAINT name HAS BEEN IGNORED BECAUSE IT IS A DUPLICATE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If the duplication is an error, correct the statement and execute it again.]]></programmersResponse>
		<sqlState>01543</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+551</code>
		<message><![CDATA[auth-id DOES NOT HAVE THE PRIVILEGE TO PERFORM OPERATION operation ON OBJECT object-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[For better performance, rebind the plan or package after correcting the statement. To correct the statement, ensure that auth-id has been granted the authority to perform the desired operation, that object-name exists, and that auth-id is not trying to create a table with a different authorization ID.]]></programmersResponse>
		<sqlState>01548</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+552</code>
		<message><![CDATA[auth-id DOES NOT HAVE THE PRIVILEGE TO PERFORM OPERATION operation]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[For better performance, rebind the plan or package after correcting the statement. To correct the statement, ensure that the authorization-ID has been granted the authority necessary to perform the desired operation.]]></programmersResponse>
		<sqlState>01542</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+558</code>
		<message><![CDATA[THE WITH GRANT OPTION IS IGNORED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[]]></programmersResponse>
		<sqlState>01516</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+561</code>
		<message><![CDATA[THE ALTER, INDEX, REFERENCES, AND TRIGGER PRIVILEGES CANNOT BE GRANTED PUBLIC AT ALL LOCATIONS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[]]></programmersResponse>
		<sqlState>01523</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+562</code>
		<message><![CDATA[A GRANT OF A PRIVILEGE WAS IGNORED BECAUSE THE GRANTEE ALREADY HAS THE PRIVILEGE FROM THE GRANTOR]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[]]></programmersResponse>
		<sqlState>01560</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+585</code>
		<message><![CDATA[THE COLLECTION collection-id APPEARS MORE THAN ONCE WHEN SETTING THE special-register SPECIAL REGISTER]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify the list that contains the duplicate. If the error is only in entering a collection-id incorrectly that happens to duplicate another entry, enter the collection-id correctly and reissue the statement. If the entry is intended to be a duplicate, no action is required.]]></programmersResponse>
		<sqlState>01625</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+599</code>
		<message><![CDATA[COMPARISON FUNCTIONS ARE NOT CREATED FOR A DISTINCT TYPE BASED ON A LONG STRING DATA TYPE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[No action is required.]]></programmersResponse>
		<sqlState>01596</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+610</code>
		<message><![CDATA[A CREATE/ALTER ON OBJECT object-name HAS PLACED OBJECT IN utility PENDING]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The following actions may be taken:
 - For REBUILD pending on an index, use the REBUILD INDEX utility to rebuild the index and remove the REBUILD pending status.
 - For REORG pending on a table space partition, perform the following steps:
 - Issue a DISPLAY DATABASE command for the table space to identify which partitions are in REORG pending. Run the REORG utility on the partitions that are in REORG pending.

For REORG pending on a table space, run the REORG utility on the table space.]]></programmersResponse>
		<sqlState>01566</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+645</code>
		<message><![CDATA[WHERE NOT NULL IS IGNORED BECAUSE THE INDEX KEY CANNOT CONTAIN NULL VALUES]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Remove the WHERE NOT NULL clause to get rid of the warning.]]></programmersResponse>
		<sqlState>01528</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+650</code>
		<message><![CDATA[THE TABLE BEING CREATED OR ALTERED CANNOT BECOME A DEPENDENT TABLE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[]]></programmersResponse>
		<sqlState>01538</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+653</code>
		<message><![CDATA[TABLE table-name IN PARTITIONED TABLESPACE tspace-name IS NOT AVAILABLE BECAUSE ITS PARTITIONED INDEX HAS NOT BEEN CREATED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[For better performance, rebind the plan or package after correcting the statement. To correct the statement, verify that the correct table was specified in the statement. If so, ensure that the partitioned index for the table has been created successfully before attempting to execute any SQL manipulative statements that reference that table.]]></programmersResponse>
		<sqlState>01551</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+655</code>
		<message><![CDATA[STOGROUP stogroup_name HAS BOTH SPECIFIC AND NON-SPECIFIC VOLUME IDS. IT WILL NOT BE ALLOWED IN FUTURE RELEASES]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Plan to use either specific or non-specific volume ids to avoid future release migration impact. ALTER STOGROUP may be used to drop all specific volume ids or all non-specific volume ids.]]></programmersResponse>
		<sqlState>01597</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+658</code>
		<message><![CDATA[THE SUBPAGES VALUE IS IGNORED FOR THE CATALOG INDEX index-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[]]></programmersResponse>
		<sqlState>01600</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+738</code>
		<message><![CDATA[DEFINITION CHANGE OF object object_name MAY REQUIRE SIMILAR CHANGE ON READ-ONLY SYSTEMS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Check the read-only shared systems that have the specified object defined, and determine if a change must be made to the object on those systems.]]></programmersResponse>
		<sqlState>01530</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+799</code>
		<message><![CDATA[A SET STATEMENT REFERENCES A SPECIAL REGISTER THAT DOES NOT EXIST AT THE SERVER SITE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[This SQLCODE can be returned to an application for any SQL statement. This SQLCODE may be masked by other negative SQLCODEs that the SQL statement receives. Processing continues at the server.]]></programmersResponse>
		<sqlState>01527</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+802</code>
		<message><![CDATA[EXCEPTION ERROR exception-type HAS OCCURRED DURING operation-type OPERATION ON data-type DATA, POSITION position-number]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine the expression for which the warning occurred to see if the cause (or the likely cause) of the problem can be determined. The problem may be data-dependent, in which case it will be necessary to examine the data that was being processed at the time the error occurred.
See the explanation of SQLCODE -405 for allowed ranges of numeric data types.]]></programmersResponse>
		<sqlState>01519</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+806</code>
		<message><![CDATA[BIND ISOLATION LEVEL RR CONFLICTS WITH TABLESPACE LOCKSIZE PAGE OR LOCKSIZE ROW AND LOCKMAX 0]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If you do not want table space locking, use isolation level UR, CS, or RS.]]></programmersResponse>
		<sqlState>01553</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+807</code>
		<message><![CDATA[THE RESULT OF DECIMAL MULTIPLICATION MAY CAUSE OVERFLOW]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[]]></programmersResponse>
		<sqlState>01554</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+863</code>
		<message><![CDATA[THE CONNECTION WAS SUCCESSFUL BUT ONLY SBCS WILL BE SUPPORTED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Do not execute any SQL statements which pass either mixed data or graphic data as input host variables.]]></programmersResponse>
		<sqlState>01539</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+883</code>
		<message><![CDATA[ROLLBACK TO SAVEPOINT OCCURED WHEN THERE WERE OPERATIONS THAT CANNOT BE UNDONE, OR AN OPERATION THAT CANNOT BE UNDONE OCCURRED WHEN THERE WAS A SAVEPOINT OUTSTANDING]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify that this is what you meant.]]></programmersResponse>
		<sqlState>01640</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+20002</code>
		<message><![CDATA[THE GBPCACHE SPECIFICATION IS IGNORED, bpname DOES NOT ALLOW CACHING]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If you want to use one of the GBPCACHE options other than NONE, you must alter the table space or index to use a group buffer pool that is defined with GBPCACHE YES.]]></programmersResponse>
		<sqlState>01624</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+20007</code>
		<message><![CDATA[USE OF OPTIMIZATION HINTS IS DISALLOWED BY A DB2 SUBSYSTEM PARAMETER. THE SPECIAL REGISTER 'OPTIMIZATION HINT' IS SET TO THE DEFAULT VALUE OF BLANKS.]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Enable the use of OPTIMIZATION HINT by changing the value of OPTIMIZATION HINTS on the DB2 Installation panel DSNTIP4.
If, after further consideration, you do not want to use an OPTIMIZATION HINT, change or remove the SET CURRENT OPTIMIZATION HINT statement.]]></programmersResponse>
		<sqlState>01602</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+20122</code>
		<message><![CDATA[DEFINE NO OPTION IS NOT APPLICABLE IN THE CONTEXT SPECIFIED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[]]></programmersResponse>
		<sqlState>01644</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+20237</code>
		<message><![CDATA[FETCH PRIOR ROWSET FOR CURSOR cursor-name RETURNED A PARTIAL ROWSET]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Analyze the situation to determine if anything should be rolled back.]]></programmersResponse>
		<sqlState>02504</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+20141</code>
		<message><![CDATA[TRUNCATION OF VALUE WITH LENGTH length OCCURRED FOR hv-or-parm-number]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the declaratoin of hv-or-parm-number to avoid truncation.]]></programmersResponse>
		<sqlState>01004</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+20245</code>
		<message><![CDATA[NOT PADDED CLAUSE IS IGNORED FOR INDEXES CREATED ON AUXILIARY TABLES]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Remove the NOT PADDED clause to avoid this warning.]]></programmersResponse>
		<sqlState>01663</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+20270</code>
		<message><![CDATA[OPTION NOT SPECIFIED FOLLOWING ALTER PARTITION CLAUSE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Specify a partition option after the ALTER PARTITION keywords to avoid this warning in the future. For an ALTER INDEX statement, if partition-element is specified, specify either the ENDING clause of:
 - partition-element
 - using-block
 - free-block
 - gbcaches-block]]></programmersResponse>
		<sqlState>01664</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+20272</code>
		<message><![CDATA[THE LAST PARTITION'S LIMIT KEY VALUE OF old-limit-key-value IS SET TO THE HIGHEST OR LOWEST POSSIBLE VALUE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[]]></programmersResponse>
		<sqlState>01666</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>+30100</code>
		<message><![CDATA[OPERATION COMPLETED SUCCESSFULLY BUT A DISTRIBUTION PROTOCOL VIOLATION HAS BEEN DETECTED. ORIGINAL SQLCODE=original-sqlcode AND ORIGINAL SQLSTATE=original-sqlstate]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Notify the System Programmer for assistance in analyzing the trace data that was generated.]]></programmersResponse>
		<sqlState>01558</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-007</code>
		<message><![CDATA[STATEMENT CONTAINS THE ILLEGAL CHARACTER character]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the syntax and resubmit the statement. Refer to Chapter 2 of DB2 SQL Reference for information about the valid SQL character set.]]></programmersResponse>
		<sqlState>42601</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-010</code>
		<message><![CDATA[THE STRING CONSTANT BEGINNING string IS NOT TERMINATED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine the statement for missing quotation marks or apostrophes in the indicated string constant.]]></programmersResponse>
		<sqlState>42603</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-029</code>
		<message><![CDATA[INTO CLAUSE REQUIRED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Add the INTO clause to the SELECT statement and precompile the application program again.]]></programmersResponse>
		<sqlState>42601</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-58</code>
		<message><![CDATA[An integer expression must be specified on a RETURN statement in an SQL procedure. The data type of the RETURN statement value in an SQL procedure must be INTEGER.]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Specify a value on the RETURN statement that has a data type of INTEGER.]]></programmersResponse>
		<sqlState>428F2</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-060</code>
		<message><![CDATA[INVALID type SPECIFICATION : spec]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement. Refer to Chapter 2 of DB2 SQL Reference for rules for length and scale.]]></programmersResponse>
		<sqlState>42815</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-079</code>
		<message><![CDATA[QUALIFIER FOR DECLARED GLOBAL TEMPORARY TABLE table-name MUST BE SESSION, NOT qualifier]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the statement in one of the following ways:
 - Change the qualifier to SESSION.
 - Remove the qualifier, and let DB2 default it to SESSION.]]></programmersResponse>
		<sqlState>428EK</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-084</code>
		<message><![CDATA[UNACCEPTABLE SQL STATEMENT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If the situation involves an SQL statement that cannot be prepared, the problem is in the source of the SQL statement, not the application program. Thus, no action is necessary unless the source of the SQL statement is the application program itself.
If the situation involves an SQL statement that is not supported by DB2, remove it from the application program and precompile again.
If the situation involves an invalid PREPARE of an ALLOCATE CURSOR statement, change the application program to use a statement identifier that is not associated with a declared cursor.]]></programmersResponse>
		<sqlState>42612</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-096</code>
		<message><![CDATA[VARIABLE variable-name DOES NOT EXIST OR IS NOT SUPPORTED BY THE SERVER AND A DEFAULT VALUE WAS NOT PROVIDED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the invocation of the function to specify a default variable for variable-name,or change the name of a variable that does exist.]]></programmersResponse>
		<sqlState>42704</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-097</code>
		<message><![CDATA[THE USE OF LONG VARCHAR OR LONG VARGRAPHIC IS NOT ALLOWED IN THIS CONTEXT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement.]]></programmersResponse>
		<sqlState>42601</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-101</code>
		<message><![CDATA[THE STATEMENT IS TOO LONG OR TOO COMPLEX]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Divide the statement into shorter or less complex SQL statements.
If the statement enables parallelism, try disabling parallelism. You may do this by using the DEGREE(1) bind option for static SQL, or by setting the CURRENT DEGREE special register to '1' for dynamic SQL.]]></programmersResponse>
		<sqlState>54001</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-102</code>
		<message><![CDATA[LITERAL STRING IS TOO LONG. STRING BEGINS string]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The requested function is not available interactively. If the error occurred in the context of an SQL statement embedded in an application program, the desired result can be achieved by assigning the long string to a host variable, and substituting that variable for the string literal in the SQL statement.]]></programmersResponse>
		<sqlState>54002</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-103</code>
		<message><![CDATA[literal IS AN INVALID NUMERIC LITERAL]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the invalid literal.]]></programmersResponse>
		<sqlState>42604</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-104</code>
		<message><![CDATA[ILLEGAL SYMBOL &quot;token&quot;. SOME SYMBOLS THAT MIGHT BE LEGAL ARE: token-list]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement and execute it again.]]></programmersResponse>
		<sqlState>42601</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-105</code>
		<message><![CDATA[INVALID STRING]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Specify the correct format of the string. Check for a graphic string, paired delimiters, the character G or N, and an even number of bytes within the string.]]></programmersResponse>
		<sqlState>42604</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-107</code>
		<message><![CDATA[THE NAME name IS TOO LONG. MAXIMUM ALLOWABLE SIZE IS size]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Choose a shorter name for the object.]]></programmersResponse>
		<sqlState>42622</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-108</code>
		<message><![CDATA[THE NAME name IS QUALIFIED INCORRECTLY]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Remove the qualifier and reissue the statement.]]></programmersResponse>
		<sqlState>42601</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-109</code>
		<message><![CDATA[clause CLAUSE IS NOT PERMITTED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the SQL statement.]]></programmersResponse>
		<sqlState>42601</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-110</code>
		<message><![CDATA[INVALID HEXADECIMAL LITERAL BEGINNING string]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the invalid string constant.]]></programmersResponse>
		<sqlState>42606</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-111</code>
		<message><![CDATA[AN AGGREGATE FUNCTION DOES NOT INCLUDE A COLUMN NAME]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[A column name must be specified as an operand to the function. Refer to Chapter 3 of DB2 SQL Reference for information about the proper usage of aggregate functions.]]></programmersResponse>
		<sqlState>42901</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-112</code>
		<message><![CDATA[THE OPERAND OF A AGGREGATE FUNCTION INCLUDES AN AGGREGATE FUNCTION OR A SCALAR FULLSELECT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the function specification. Refer to Chapter 3 of DB2 SQL Reference for information about the proper usage of aggregate functions.]]></programmersResponse>
		<sqlState>42607</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-113</code>
		<message><![CDATA[INVALID CHARACTER FOUND IN: string, REASON CODE nnn]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the name.]]></programmersResponse>
		<sqlState>42602</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-114</code>
		<message><![CDATA[THE LOCATION NAME location DOES NOT MATCH THE CURRENT SERVER]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Take one of these actions to resolve the mismatch:
 - Change the location qualifier to match the CURRENT SERVER special register.
 - Issue an SQL CONNECT to the location where the stored procedure resides before issuing the SQL statement. Ensure that the SQL CALL statement is issued before the ASSOCIATE LOCATORS or DESCRIBE PROCEDURE.
 - Bind the package containing the 3-part SQL procedure name with the BIND option DBPROTOCOL(DRDA). With this option, DB2 implicitly uses the DRDA protocol for remote access to the stored procedure.
 - Correct the statements so that the exact syntax used to specify the procedure name on the CALL statement be the same as that on the ASSOCIATE LOCATOR and/or DESCRIBE PROCEDURE. If an unqualified name is used to CALL the procedure, the 1-part name must also be used on the other statements. If the CALL statement is made with a 3-part name, and the current server is the same as the location in the 3-part name, the ASSOCIATE LOCATOR or DESCRIBE procedure can omit the location.]]></programmersResponse>
		<sqlState>42961</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-115</code>
		<message><![CDATA[A PREDICATE IS INVALID BECAUSE THE COMPARISON OPERATOR operator IS FOLLOWED BY A PARENTHESIZED LIST OR BY ANY OR ALL WITHOUT A SUBQUERY]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the SQL statement. Refer to Chapter 5 of DB2 SQL Reference for information about the syntax of SQL statements.]]></programmersResponse>
		<sqlState>42601</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-117</code>
		<message><![CDATA[THE NUMBER OF VALUES ASSIGNED IS NOT THE SAME AS THE NUMBER OF SPECIFIED OR IMPLIED COLUMNS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement to specify one and only one value for each of the specified object columns.]]></programmersResponse>
		<sqlState>42802</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-118</code>
		<message><![CDATA[THE OBJECT TABLE OR VIEW OF THE DELETE OR UPDATE STATEMENT IS ALSO IDENTIFIED IN A FROM CLAUSE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The implied function is not supported by DB2. It may be possible to obtain the desired result by creating a temporary copy of the object table or view and addressing the subselect to that copy. Refer to Chapter 5 of DB2 SQL Reference for information about the syntax of SQL statements.]]></programmersResponse>
		<sqlState>42902</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-119</code>
		<message><![CDATA[A COLUMN IDENTIFIED IN A HAVING CLAUSE IS NOT INCLUDED IN THE GROUP BY CLAUSE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Refer to Chapter 4 of DB2 SQL Reference for information about the proper usage of HAVING and GROUP BY clauses.]]></programmersResponse>
		<sqlState>42803</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-120</code>
		<message><![CDATA[AN AGGREGATE FUNCTION IS NOT VALID IN THE CONTEXT IN WHICH IT WAS INVOKED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The implied function is not supported by DB2. Refer to Chapter 4 of DB2 SQL Reference for information about restrictions on operands that can be specified within a WHERE clause, SET clause, VALUES clause, SET host-variable statement, SET transition-variable statement, assignment statement, or as the expression of a RETURN statement.]]></programmersResponse>
		<sqlState>42903</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-121</code>
		<message><![CDATA[THE COLUMN name IS IDENTIFIED MORE THAN ONCE IN THE INSERT OR UPDATE OR SET TRANSITION VARIABLE STATEMENT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the syntax of the statement so that each column name is specified only once.]]></programmersResponse>
		<sqlState>42701</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-122</code>
		<message><![CDATA[A SELECT STATEMENT WITH NO GROUP BY CLAUSE CONTAINS A COLUMN NAME AND AN AGGREGATE FUNCTION IN THE SELECT CLAUSE OR A COLUMN NAME IS CONTAINED IN THE SELECT CLAUSE BUT NOT IN THE GROUP BY CLAUSE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[You can correct the statement by:
 - including the columns in the GROUP BY clause that are in the SELECT clause, or
 - removing the columns from the SELECT clause.

Refer to Chapter 4 of DB2 SQL Reference for information about the use of GROUP BY clauses in SQL statements.]]></programmersResponse>
		<sqlState>42803</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-123</code>
		<message><![CDATA[THE PARAMETER IN POSITION n IN THE FUNCTION name MUST BE A CONSTANT OR KEYWORD]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Action: Ensure that each argument of the function conforms to the definition of the corresponding parameter.]]></programmersResponse>
		<sqlState>42601</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-125</code>
		<message><![CDATA[AN INTEGER IN THE ORDER BY CLAUSE DOES NOT IDENTIFY A COLUMN OF THE RESULT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the syntax of the ORDER BY clause such that each column identifier properly denotes a column of the result table.]]></programmersResponse>
		<sqlState>42805</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-126</code>
		<message><![CDATA[THE SELECT STATEMENT CONTAINS BOTH AN UPDATE CLAUSE AND AN ORDER BY CLAUSE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The implied function is not supported by DB2. A cursor that is to be used for update cannot be defined to fetch the rows of the object table in a specific order.
Refer to Chapter 4 of DB2 SQL Reference for information about restrictions on the declarations for cursors to be used for update.]]></programmersResponse>
		<sqlState>42829</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-127</code>
		<message><![CDATA[DISTINCT IS SPECIFIED MORE THAN ONCE IN A SUBSELECT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The implied function is not supported by DB2. Refer to Chapter 4 of DB2 SQL Reference for information about restriction on the use of hte DISTINCT qualifier.]]></programmersResponse>
		<sqlState>42905</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-128</code>
		<message><![CDATA[INVALID USE OF NULL IN A PREDICATE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The implied function is not supported by DB2. Refer to Chapter 2 of DB2 SQL Reference for information about the proper use of the NULL operand.]]></programmersResponse>
		<sqlState>42601</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-129</code>
		<message><![CDATA[THE STATEMENT CONTAINS TOO MANY TABLE NAMES]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Break the SQL statement into two or more simpler statements with less than 225 table references in each. The count will include the number of base table occurrences from each table or view on the FROM list. Refer to Chapter 4 of DB2 SQL Reference for the definition of a subselect.]]></programmersResponse>
		<sqlState>54004</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-130</code>
		<message><![CDATA[THE ESCAPE CLAUSE CONSISTS OF MORE THAN ONE CHARACTER, OR THE STRING PATTERN CONTAINS AN INVALID OCCURRENCE OF THE ESCAPE CHARACTER]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the string pattern, or choose a different ESCAPE character and change the pattern accordingly, or eliminate the use of the Escape Clause on the LIKE or NOT LIKE predicate where the column name to the left has the MIXED subtype.]]></programmersResponse>
		<sqlState>22019 if other than invalid ESCAPE pattern. 22025 if invalid ESCAPE pattern.</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-131</code>
		<message><![CDATA[STATEMENT WITH LIKE PREDICATE HAS INCOMPATIBLE DATA TYPES]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Check the data type of every operand.]]></programmersResponse>
		<sqlState>42818</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-132</code>
		<message><![CDATA[AN OPERAND OF value IS NOT VALID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Check and correct the syntax of the LIKE predicate, or LOCATE or POSSTR scalar function.]]></programmersResponse>
		<sqlState>42824</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-133</code>
		<message><![CDATA[AN AGGREGATE FUNCTION IN A SUBQUERY OF A HAVING CLAUSE IS INVALID BECAUSE ALL COLUMN REFERENCES IN ITS ARGUMENT ARE NOT CORRELATED TO THE GROUP BY RESULT THAT THE HAVING CLAUSE IS APPLIED TO]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Refer to Chapter 4 of DB2 SQL Reference for information about restrictions on the syntax of the HAVING clause.]]></programmersResponse>
		<sqlState>42906</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-134</code>
		<message><![CDATA[IMPROPER USE OF LONG STRING COLUMN OR AN EXPRESSION THAT RESOLVES TO A LONG STRING name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[DB2 does not support the requested operation on a long string value. Refer to Chapter 2 of DB2 SQL Reference for information about restrictions on the specification and manipulation of long string values.]]></programmersResponse>
		<sqlState>42907</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-136</code>
		<message><![CDATA[SORT CANNOT BE EXECUTED BECAUSE THE SORT KEY LENGTH IS GREATER THAN 16000 BYTES]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The statement must be modified such that the internal length of the sort key will not exceed the maximum limit. In general, this means that one or more column names must be deleted from the ORDER BY or GROUP BY clause, or the list following the DISTINCT qualifier.]]></programmersResponse>
		<sqlState>54005</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-137</code>
		<message><![CDATA[THE LENGTH RESULTING FROM operation IS GREATER THAN maximum-length]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure that the length of the result does not exceed the defined maximum.]]></programmersResponse>
		<sqlState>54006</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-138</code>
		<message><![CDATA[THE SECOND OR THIRD ARGUMENT OF THE SUBSTR FUNCTION IS OUT OF RANGE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure that the second and third arguments of the SUBSTR function have legal values according the above rules.]]></programmersResponse>
		<sqlState>22011</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-142</code>
		<message><![CDATA[THE SQL STATEMENT IS NOT SUPPORTED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the syntax of the SQL statement or remove the statement from the program.]]></programmersResponse>
		<sqlState>42612</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-144</code>
		<message><![CDATA[INVALID SECTION NUMBER number]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[For case 1: If you are executing a package that was bound with SQLERROR(CONTINUE), determine whether the statement in question was bound as a valid section. You can use the following statements to query the DB2 catalog:
<pre>SELECT SQLERROR
FROM SYSIBM.SYSPACKAGE
WHERE COLLID = collection-id AND NAME = package-id AND VERSION = version-name;</pre>

If that query returns 'C', the package was bound with SQLERROR(CONTINUE).
<pre>SELECT STMTNO, TEXT
FROM SYSIBM.SYSPACKSTMT
WHERE COLLID = collection-id AND NAME = package-id AND VERSION = version-name AND SECTNO = number AND BINDERROR = 'Y';</pre>

If that query returns any rows, the section is invalid. Refer to the error messages issued during the bind to determine the cause. Correct any errors and bind the package again, using the REPLACE option.
For case 2: If the DB2 system has fallen back to a previous release, determine whether there are any SQL statements with a section number of zero that are not supported by that release. You can use the following statements to query the DB2 catalog.
When executing from a DBRM, use:
<pre>SELECT *
FROM SYSIBM.SYSSTMT
WHERE SECTNO = 0
ORDER BY NAME, PLNAME, STMTNO, SEQNO;</pre>

When executing from a package, use:
<pre>SELECT *
FROM SYSIBM.SYSPACKSTMT
WHERE SECTNO = 0
ORDER BY COLLID, NAME, VERSION, STMTNO, SEQNO;</pre>

For case 3: Examine the application to determine whether the call parameter list was changed in some way. In general, you should not attempt to change the output of the precompiler.]]></programmersResponse>
		<sqlState>58003</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-147</code>
		<message><![CDATA[ALTER FUNCTION function-name FAILED BECAUSE SOURCE FUNCTIONS CANNOT BE ALTERED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the statement to refer to a function that can be altered, or recreate the function by dropping it and then creating a new version of it.]]></programmersResponse>
		<sqlState>42809</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-148</code>
		<message><![CDATA[THE SOURCE TABLE source-name CANNOT BE RENAMED OR ALTERED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[For case:
 - 1 Drop all views, inactivate the RLST table, or drop the synonym.
 - 2 Avoid referential integrity relations, user exits, or global temporary tables.
 - 3 Run REORG INDEX, REORG TABLESPACE, or REBUILD INDEX. If the index is partitioned, then run the utility on all the partitions. Reissue the statement.]]></programmersResponse>
		<sqlState>42809</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-150</code>
		<message><![CDATA[THE OBJECT OF THE INSERT, DELETE, OR UPDATE STATEMENT IS A VIEW, SYSTEM-MAINTAINED MATERIALIZED QUERY TABLE, OR TRANSITION TABLE FOR WHICH THE REQUESTED OPERATION IS NOT PERMITTED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The requested function cannot be performed on the view. Refer to Chapter 5 of DB2 SQL Reference for further information regarding inserting, deleting, and updating views.
If the error occurred on a CREATE TRIGGER statement, remove the INSERT, UPDATE, or DELETE reference to the transition table.
If the table is a system-maintained materialized query table, the requested function cannot be performed on that table. Refer to the description of the REFRESH TABLE statement in Chapter 5 of .]]></programmersResponse>
		<sqlState>42807</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-151</code>
		<message><![CDATA[THE UPDATE STATEMENT IS INVALID BECAUSE THE CATALOG DESCRIPTION OF COLUMN column-name INDICATES THAT IT CANNOT BE UPDATED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The requested function is not supported by DB2. Refer to the description of the UPDATE statement in Chapter 5 of DB2 SQL Reference for information about restrictions on the ability to update ROWID columns, identity columns, and columns in partitioned tables and views.]]></programmersResponse>
		<sqlState>42808</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-152</code>
		<message><![CDATA[THE DROP clause CLAUSE IN THE ALTER STATEMENT IS INVALID BECAUSE constraint-name IS A constraint-type]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Drop the existing object with the correct DROP clause of the ALTER TABLE statement.]]></programmersResponse>
		<sqlState>42809</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-153</code>
		<message><![CDATA[THE STATEMENT IS INVALID BECAUSE THE VIEW OR TABLE DEFINITION DOES NOT INCLUDE A UNIQUE NAME FOR EACH COLUMN]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement by providing a list of names for the columns of the view or table. Refer to Chapter 5 of DB2 SQL Reference for information about the syntax of the CREATE VIEW statement, the CREATE TABLE statement, or the DECLARE GLOBAL TEMPORARY TABLE statement.]]></programmersResponse>
		<sqlState>42908</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-154</code>
		<message><![CDATA[THE STATEMENT FAILED BECAUSE VIEW OR TABLE DEFINITION IS NOT VALID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Refer to Chapter 5 of DB2 SQL Reference for information about restrictions on the definitions for views, materialized query tables, or declared temporary tables.]]></programmersResponse>
		<sqlState>42909</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-156</code>
		<message><![CDATA[THE STATEMENT DOES NOT IDENTIFY A TABLE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify that the proper name was specified in the statement.]]></programmersResponse>
		<sqlState>42809</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-157</code>
		<message><![CDATA[ONLY A TABLE NAME CAN BE SPECIFIED IN A FOREIGN KEY CLAUSE. object-name IS NOT THE NAME OF A TABLE.]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement to specify a table name in the foreign key clause.]]></programmersResponse>
		<sqlState>42810</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-158</code>
		<message><![CDATA[THE NUMBER OF COLUMNS SPECIFIED FOR THE VIEW OR TABLE IS NOT THE SAME AS THE NUMBER OF COLUMNS SPECIFIED BY THE FULLSELECT, OR THE NUMBER OF COLUMNS SPECIFIED IN THE CORRELATION CLAUSE IN A FROM CLAUSE IS NOT THE SAME AS THE NUMBER OF COLUMNS IN THE CORRESPONDING TABLE, VIEW, TABLE EXPRESSION, OR TABLE FUNCTION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the syntax of the statement to specify a column name for each column in the corresponding object (table, view, etc.). Refer to Chapter 5 of DB2 SQL Reference for information about the syntax of the statement.]]></programmersResponse>
		<sqlState>42811</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-159</code>
		<message><![CDATA[THE STATEMENT REFERENCES object-name WHICH IDENTIFIES AN object-type RATHER THAN AN expected-object-type]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the statement to match the type of object that is identified by expected-object-type. For example:
 - An ALTER VIEW statement must reference an existing view.
 - A COMMENT ON ALIAS statement must specify the name of an alias, and not the name of a table or view.
 - A COMMENT ON TABLE statement must reference an existing table or view.
 - A CREATE INDEX statement with the UNIQUE keyword must specify a table that is not a materialized query table.
 - A CREATE TRIGGER statement must specify a table in the ON clause that is not a materialized query table. That is, a trigger cannot be defined for a materialized query table.
 - A DROP ALIAS statement must specify the name of an alias, and not the name of a table or view.
 - A DROP TABLE statement must reference an existing table. If an alias is specified, then the table that the alias refers to is dropped. Use the DROP ALIAS statement to drop the alias.
 - A DROP VIEW statement must reference an existing view.
 - A REFRESH TABLE statement must refer to a materialized query table.]]></programmersResponse>
		<sqlState>42809</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-160</code>
		<message><![CDATA[THE WITH CHECK OPTION CANNOT BE USED FOR THE SPECIFIED VIEW]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Refer to Chapter 5 of DB2 SQL Reference for rules regarding use of the WITH CHECK OPTION in view definitions.]]></programmersResponse>
		<sqlState>42813</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-161</code>
		<message><![CDATA[THE INSERT OR UPDATE IS NOT ALLOWED BECAUSE A RESULTING ROW DOES NOT SATISFY THE VIEW DEFINITION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine the view definition to determine why the requested INSERT or UPDATE was rejected. Note that this may be a data-dependent condition.]]></programmersResponse>
		<sqlState>44000</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-164</code>
		<message><![CDATA[auth-id1 DOES NOT HAVE THE PRIVILEGE TO CREATE A VIEW WITH QUALIFICATION authorization-ID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Do not attempt to create views with other than your own ID as a qualifier. Only an authorization ID that holds 'SYSADM' or 'DBADM' authority can create views for other authorization IDs. The DBADM privilege should be granted on any of the databases that contain at least one of the tables on which this CREATE VIEW is based.]]></programmersResponse>
		<sqlState>42502</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-170</code>
		<message><![CDATA[THE NUMBER OF ARGUMENTS SPECIFIED FOR function-name IS INVALID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement. Refer to Chapter 3 of DB2 SQL Reference for information about the number of arguments required by the scalar function 'function-name'.]]></programmersResponse>
		<sqlState>42605</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-171</code>
		<message><![CDATA[THE DATA TYPE, LENGTH, OR VALUE OF ARGUMENT nn OF function-name IS INVALID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement. Refer to Chapter 3 of DB2 SQL Reference for rules for each argument of the scalar function function-name.]]></programmersResponse>
		<sqlState>42815</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-173</code>
		<message><![CDATA[UR IS SPECIFIED ON THE WITH CLAUSE BUT THE CURSOR IS NOT READ-ONLY]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If the cursor is intended to be read-only but is ambiguous, add the FOR FETCH ONLY clause. If the cursor is updateable, change the isolation level specified on the WITH clause.]]></programmersResponse>
		<sqlState>42801</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-180</code>
		<message><![CDATA[THE DATE, TIME, OR TIMESTAMP VALUE value IS INVALID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the program to ensure the specified value conforms to the syntax of DATE, TIME, and TIMESTAMP. Refer to Chapter 2 of DB2 SQL Reference for a list of valid DATE and TIME formats.]]></programmersResponse>
		<sqlState>22007</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-181</code>
		<message><![CDATA[THE STRING REPRESENTATION OF A DATETIME VALUE IS NOT A VALID DATETIME VALUE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Check whether the value is within the valid range and is in the proper format. Refer to Chapter 2 of DB2 SQL Reference for information on string data formats.]]></programmersResponse>
		<sqlState>22007</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-182</code>
		<message><![CDATA[AN ARITHMETIC EXPRESSION WITH A DATETIME VALUE IS INVALID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the indicated arithmetic expression.]]></programmersResponse>
		<sqlState>42816</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-183</code>
		<message><![CDATA[AN ARITHMETIC OPERATION ON A DATE OR TIMESTAMP HAS A RESULT THAT IS NOT WITHIN THE VALID RANGE OF DATES]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine the SQL statement to see if the cause of the problem can be determined. The problem may be data-dependent, in which case it will be necessary to examine the data that was processed at the time the error occurred.]]></programmersResponse>
		<sqlState>22008</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-184</code>
		<message><![CDATA[AN ARITHMETIC EXPRESSION WITH A DATETIME VALUE CONTAINS A PARAMETER MARKER]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the indicated arithmetic expression.]]></programmersResponse>
		<sqlState>42610</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-185</code>
		<message><![CDATA[THE LOCAL FORMAT OPTION HAS BEEN USED WITH A DATE OR TIME AND NO LOCAL EXIT HAS BEEN INSTALLED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Contact the system programmer about installation of the date or time exit.]]></programmersResponse>
		<sqlState>57008</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-186</code>
		<message><![CDATA[THE LOCAL DATE LENGTH OR LOCAL TIME LENGTH HAS BEEN INCREASED AND EXECUTING PROGRAM RELIES ON THE OLD LENGTH]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If the statement receiving this error is embedded in the application program, then a REBIND command must be issued for the application plan. If the statement was dynamic SQL, then the statement can be reentered.]]></programmersResponse>
		<sqlState>22505</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-187</code>
		<message><![CDATA[A REFERENCE TO A CURRENT DATETIME SPECIAL REGISTER IS INVALID BECAUSE THE MVS TOD CLOCK IS BAD OR THE MVS PARMTZ IS OUT OF RANGE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[For CURRENT TIMEZONE, check that the MVS parameter PARMTZ is between -24 and +24 hours. For the other CURRENT special registers, check that the MVS TOD clock has been set correctly.]]></programmersResponse>
		<sqlState>22506</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-188</code>
		<message><![CDATA[THE STRING REPRESENTATION OF A NAME IS INVALID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the value of the host variable so that it is a valid string representation of a name.]]></programmersResponse>
		<sqlState>22503</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-189</code>
		<message><![CDATA[CCSID ccsid IS INVALID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure that the CCSSID is valid and consistent with the data type of the string. If a valid CCSID is not listed in a built-in row of SYSSTRINGS, it can be defined by inserting a user-provided row. If a valid CCSID is misclassified in a user-provided row, that row can be updated to correct the mistake. Refer to the appendices of DB2 Installation Guide for more information on CCSIDs and to DB2 SQL Reference for more information on the SYSSTRINGS catalog table.
If a graphic CCSID had not been specified at system installation, update your DECP to include a graphic CCSID and recycle your DB2.]]></programmersResponse>
		<sqlState>22522</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-190</code>
		<message><![CDATA[THE ATTRIBUTES SPECIFIED FOR THE COLUMN column-name ARE NOT COMPATIBLE WITH THE EXISTING COLUMN DEFINITION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Make the attributes that are specified in the statement compatible with the existing column definition, remove the attribute specification, or specify a different column name.]]></programmersResponse>
		<sqlState>42837</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-191</code>
		<message><![CDATA[A STRING CANNOT BE USED BECAUSE IT IS INVALID MIXED DATA]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If the string contains the intended information, the description of the column or host variable should be changed from MIXED DATA to BIT or SBCS DATA. If the description of the column or host variable is correct, the string is the problem and it must be changed to conform to the rules for well-formed mixed data. For more information about well-formed MIXED DATA refer to Chapter 2 of DB2 SQL Reference.]]></programmersResponse>
		<sqlState>22504</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-197</code>
		<message><![CDATA[QUALIFIED COLUMN NAMES IN ORDER BY CLAUSE NOT PERMITTED WHEN UNION OR UNION ALL SPECIFIED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the statement so that qualified names are not necessary in the ORDER BY clause.
System Action: The statement is not executed.]]></programmersResponse>
		<sqlState>42877</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-198</code>
		<message><![CDATA[THE OPERAND OF THE PREPARE OR EXECUTE IMMEDIATE STATEMENT IS BLANK OR EMPTY]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the logic of the application program to ensure that a valid SQL statement is provided in the operand of the PREPARE or EXECUTE IMMEDIATE statement before that statement is executed.]]></programmersResponse>
		<sqlState>42617</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-199</code>
		<message><![CDATA[ILLEGAL USE OF KEYWORD keyword. TOKEN token-list WAS EXPECTED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine the statement in the area of keyword keyword. A colon or SQL delimiter might be missing.
Verify that the clauses are in the correct order. If the reserved word that is identified in the messages is listed as a reserved word, make the word a delimited identifier.]]></programmersResponse>
		<sqlState>42601</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-203</code>
		<message><![CDATA[A REFERENCE TO COLUMN column-name IS AMBIGUOUS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If the problem is caused by a nonunique column name in a nested table expression, change the nested table expression so that the column name is unique. If the problem is caused by the use of an unqualified name, qualify it with a table, view, or correlation name.]]></programmersResponse>
		<sqlState>42702</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-204</code>
		<message><![CDATA[name IS AN UNDEFINED NAME]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify that the object name was correctly specified in the SQL statement, including any required qualifiers. If it is correct, ensure that the object exists in the system before resubmitting the statement.
If the specified object is a routine, execute the CREATE PROCEDURE or CREATE FUNCTION statement to define the routine to DB2. Issue the -START PROCEDURE command to activate the new definition.]]></programmersResponse>
		<sqlState>42704</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-205</code>
		<message><![CDATA[column-name IS NOT A COLUMN OF TABLE table-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify that the column and table names are specified correctly (including any required qualifiers) in the SQL statement.]]></programmersResponse>
		<sqlState>42703</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-206</code>
		<message><![CDATA[column-name IS NOT A COLUMN OF AN INSERTED TABLE, UPDATED TABLE, OR ANY TABLE IDENTIFIED IN A FROM CLAUSE, OR IS NOT A COLUMN OF THE TRIGGERING TABLE OF A TRIGGER]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify that the column and table names are specified correctly in the SQL statement. In the case of a SELECT statement, check to be sure that all of the required tables were named in the FROM clause.
In the case of a CREATE TRIGGER statement, ensure that only new transition variables are specified on the left side of assignments in the SET transition-variable statement and that any reference to columns of the triggering table are qualified with a transition variable correlation name.]]></programmersResponse>
		<sqlState>42703</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-208</code>
		<message><![CDATA[THE ORDER BY CLAUSE IS INVALID BECAUSE COLUMN name IS NOT PART OF THE RESULT TABLE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the syntax of the statement, either by adding the specified column to the result table, or deleting it from the ORDER BY clause. Refer to Chapter 4 of DB2 SQL Reference for information about restrictions on the use of the ORDER BY clause to order the result of an SQL SELECT.]]></programmersResponse>
		<sqlState>42707</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-212</code>
		<message><![CDATA[name IS SPECIFIED MORE THAN ONCE IN THE REFERENCING CLAUSE OF A TRIGGER DEFINITION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the statement to specify unique names for all transition variables and tables in the REFERENCING clause and resubmit the CREATE TRIGGER request.]]></programmersResponse>
		<sqlState>42712</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-214</code>
		<message><![CDATA[AN EXPRESSION IN THE FOLLOWING POSITION, OR STARTING WITH position-or-expression-start IN THE clause-type CLAUSE IS NOT VALID. REASON CODE = reason-code]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Modify the select-statement based on the reason specified by the reason-code. Use one of the following suggestions to modify the select-statment:
 - Remove the expression from the ORDER BY clause. If attempting to reference a column of the result, change the sort key to the simple-integer or simple-column-name form. See the ORDER BY syntax diagram in the DB2 SQL Reference for more information
 - Remove DISTINCT from the SELECT clause.
 - Change the expression in the ORDER BY or GROUP BY clause to an aggregate function or change the clause to use a numeric column identifier or a column name.
 - Add a GROUP BY clause or remove the aggregate function from the ORDER BY clause.
 - Remove the scalar fullselect from the GROUP BY clause.
 - Remove the scalar fullselect from the statement.]]></programmersResponse>
		<sqlState>42822</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-216</code>
		<message><![CDATA[THE NUMBER OF ELEMENTS ON EACH SIDE OF A PREDICATE OPERATOR DOES NOT MATCH. PREDICATE OPERATOR IS operator.]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the number of expressions to match the number of values returned by the fullselect or vice versa.]]></programmersResponse>
		<sqlState>428C4</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-219</code>
		<message><![CDATA[THE REQUIRED EXPLANATION TABLE table-name DOES NOT EXIST]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Determine whether the required explanation table does exist. If not, create the required table.]]></programmersResponse>
		<sqlState>42704</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-220</code>
		<message><![CDATA[THE COLUMN column-name IN EXPLANATION TABLE table-name IS NOT DEFINED PROPERLY]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the definition of the required explanation table. Refer to Chapter 5 of DB2 SQL Reference for information on defining an explanation table.]]></programmersResponse>
		<sqlState>55002</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-221</code>
		<message><![CDATA[&quot;SET OF OPTIONAL COLUMNS&quot; IN EXPLANATION TABLE table-name IS INCOMPLETE. OPTIONAL COLUMN column-name IS MISSING]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the definition of the required explanation table to include all of the optional columns in the chosen format, just the Version 2 Release 2 optional columns, or no optional columns. Refer to Chapter 5 of DB2 SQL Reference for information on defining an explanation table.]]></programmersResponse>
		<sqlState>55002</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-222</code>
		<message><![CDATA[AN UPDATE OR DELETE OPERATION WAS ATTEMPTED AGAINST A HOLE USING CURSOR cursor-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Issue a FETCH statement to position the cursor on a row.]]></programmersResponse>
		<sqlState>24510</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-224</code>
		<message><![CDATA[THE RESULT TABLE DOES NOT AGREE WITH THE BASE TABLE USING cursor-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the application program to handle this error condition or change isolation levels so the base row cannot be updated during the cursor operation.]]></programmersResponse>
		<sqlState>24512</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-225</code>
		<message><![CDATA[FETCH STATEMENT FOR cursor-name IS NOT VALID BECAUSE THE CURSOR IS NOT DEFINED AS SCROLL]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the FETCH statement to excluse the disallowed keyword, or corect the DECLARE CURSOR statement to include the appropriate SCROLL option.]]></programmersResponse>
		<sqlState>42872</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-227</code>
		<message><![CDATA[FETCH fetch-orientation IS NOT ALLOWED, BECAUSE CURSOR cursor-name HAS AN UNKNOWN POSITION (sqlcode,sqlstate)]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Close and reopen the cursor to reset the position. For scrollable cursors, you can change the FETCH statement to specify one of the other fetch orientations (such as FIRST, LAST, BEFORE, AFTER, or ABSOLUTE) to establish a valid cursor position and fetch a row of data.]]></programmersResponse>
		<sqlState>24513</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-228</code>
		<message><![CDATA[FOR UPDATE CLAUSE SPECIFIED FOR READ-ONLY CURSOR cursor-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[To define a scrollable cursor that is read-only, specify INSENSITIVE SCROLL, but do not specify FOR UPDATE clause. To define a scrollable cursor that can be updated, specify SENSITIVE SCROLL. Corect the application program to DECLARE CURSOR appropriately.]]></programmersResponse>
		<sqlState>42620</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-229</code>
		<message><![CDATA[THE LOCALE locale SPECIFIED IN A SET LOCALE OR OTHER STATEMENT THAT IS LOCALE SENSITIVE WAS NOT FOUND]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If the statement was a SET LOCALE statement, re-specify a locale that is correct (known and available to DB2). Refer to Chapter 3 of SQL Reference for more information on Locales. If the statement was something other than SET LOCALE, then the statement contained a locale sensitive interface (the UPPER function is an example of a locale sensitive interface). Issue &quot;SELECT CURRENT LOCALE FROM SYSIBM.SYSDUMMY1&quot; to determine the value of the LOCALE in use by your program. Possible reasons for this message include an incorrect LOCALE bind option, or an incorrect LOCALE default value specified at installation time (The value of a Locale is not validated until it is needed in a Locale sensitive interface). Because Locales are dynamic in nature, they can be added, created, or deleted at anytime, they are not validated until they are used. Therefore, it is possible to specify a locale that is not valid at installation or bind time.]]></programmersResponse>
		<sqlState>42708</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-240</code>
		<message><![CDATA[THE PART CLAUSE OF A LOCK TABLE STATEMENT IS INVALID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Determine whether the specified table resides in a partitioned table space defined with LOCKPART YES.

If it is partitioned and defined with LOCKPART YES, specify a PART clause that identifies the partition you want to lock.
If it is partitioned but does not have the LOCKPART YES attribute and you want to lock a single partition, use ALTER TABLESPACE to change the LOCKPART attribute to YES.
If it is not partitioned, do not specify the PART clause.]]></programmersResponse>
		<sqlState>428B4</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-242</code>
		<message><![CDATA[THE OBJECT NAMED object-name OF TYPE object-type WAS SPECIFIED MORE THAN ONCE IN THE LIST OF OBJECTS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the error by removing from the list all duplicate occurrences of the object.]]></programmersResponse>
		<sqlState>42713</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-243</code>
		<message><![CDATA[SENSITIVE CURSOR cursor-name CANNOT BE DEFINED FOR THE SPECIFIED SELECT STATEMENT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Either change the content of the query to result in a result table that is not read-only, or change the type of cursor to be INSENSITIVE or ASENSITIVE.]]></programmersResponse>
		<sqlState>36001</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-244</code>
		<message><![CDATA[SENSITIVITY sensitivity SPECIFIED ON THE FETCH IS NOT VALID FOR CURSOR cursor-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change or remove the sensitivity option that is specified on the FETCH.]]></programmersResponse>
		<sqlState>428F4</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-245</code>
		<message><![CDATA[THE INVOCATION OF FUNCTION routine-name IS AMBIGUOUS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Fix the problem and retry. This could involve a change to the SQL statement, changing the definition of a funtion, or a change to the user's SQL path. See the DB2 Application Programming and SQL Guide for details on function resolution.]]></programmersResponse>
		<sqlState>428F5</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-246</code>
		<message><![CDATA[STATEMENT USING CURSOR cursor-name SPECIFIED NUMBER OF ROWS num-rows WHICH IS NOT VALID WITH dimension]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the application to either declare, or allocate a host-variable-array that is large enough to contain the number of rows specified in the statement, or update the value of num-rows to a value within the valid range.]]></programmersResponse>
		<sqlState>42873</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-247</code>
		<message><![CDATA[A HOLE WAS DETECTED ON A MULTIPLE ROW FETCH STATEMENT USING CURSOR cursor-name, BUT INDICATOR VARIABLES WERE NOT PROVIDED TO DETECT THE CONDITION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the FETCH statement to provide at least one indicator variable, and resubmit the statement.]]></programmersResponse>
		<sqlState>24519</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-248</code>
		<message><![CDATA[A POSITIONED DELETE OR UPDATE STATEMENT FOR CURSOR cursor-name SPECIFIED ROW n OF A ROWSET, BUT THE ROW IS NOT CONTAINED WITHIN THE CURRENT ROWSET]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Reissue the positioned UPDATE or DELETE with a value that corresponds to a row of the current rowset. If the row that is specified is outside of the current rowset, then do the following:
 - Use the FOR n ROWS clause on a FETCH CURRENT ROWSET statement to specify that the rowset contains a larger number of rows
 - Reissue the positioned UPDATE or DELETE statement.

If this message is issued because a partial rowset was returned,

Update the application logic to detect that the actual rowset size was less than the rowset size that was requested
Ensure that a positioned UPDATE or DELETE statement only refers to rows of the current rowset.]]></programmersResponse>
		<sqlState>24521</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-249</code>
		<message><![CDATA[DEFINITION OF ROWSET ACCESS FOR CURSOR cursor-name IS INCONSISTENT WITH THE FETCH ORIENTATION CLAUSE clause SPECIFIED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the fetch orientation, or redefine the cursor.]]></programmersResponse>
		<sqlState>24523</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-250</code>
		<message><![CDATA[THE LOCAL LOCATION NAME IS NOT DEFINED WHEN PROCESSING A THREE-PART OBJECT NAME]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Define the local location name and then retry the function.]]></programmersResponse>
		<sqlState>42718</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-251</code>
		<message><![CDATA[TOKEN name IS NOT VALID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the name and reissue the statement.]]></programmersResponse>
		<sqlState>42602</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-253</code>
		<message><![CDATA[A NON-ATOMIC statement STATEMENT SUCCESSFULLY COMPLETED FOR SOME OF THE REQUESTED ROWS, POSSIBLY WITH WARNINGS, AND ONE OR MORE ERRORS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Analyze the error and warning conditions to determine if the statement should be rolled back.]]></programmersResponse>
		<sqlState>22529</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-254</code>
		<message><![CDATA[A NON-ATOMIC statement STATEMENT ATTEMPTED TO PROCESS MULTIPLE ROWS OF DATA, BUT ERRORS OCCURRED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Analyze the error and warning conditions to determine the appropriate corrective actions.]]></programmersResponse>
		<sqlState>22530</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-270</code>
		<message><![CDATA[FUNCTION NOT SUPPORTED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Alter the materialized query table into a base table before performing the alteration, or drop and recreate the materialized query table.
If this error is caused by an XML data type, input the XML data to one of the functions that accept XML input. Store the output of the function in the database, or return it to the application.]]></programmersResponse>
		<sqlState>42997</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-300</code>
		<message><![CDATA[THE STRING CONTAINED IN HOST VARIABLE OR PARAMETER position-number IS NOT NUL-TERMINATED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Append a NUL-terminator to the end of the string.]]></programmersResponse>
		<sqlState>22024</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-301</code>
		<message><![CDATA[THE VALUE OF INPUT HOST VARIABLE OR PARAMETER NUMBER position-number CANNOT BE USED AS SPECIFIED BECAUSE OF ITS DATA TYPE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the application program, function or stored procedure. Ensure that the data type of the indicated input host variable or parameter in the statement is compatible with the way it is used.]]></programmersResponse>
		<sqlState>42895</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-302</code>
		<message><![CDATA[THE VALUE OF INPUT VARIABLE OR PARAMETER NUMBER position-number IS INVALID OR TOO LARGE FOR THE TARGET COLUMN OR THE TARGET VALUE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the application program, function or stored procedure. Check the column type and length of the value or the data type and contents of the input host variable or parameter position-number. Ensure that the value of the host variable or parameter will fit in the column or contains valid decimal data. Valid decimal data is a System/370 packed decimal number.]]></programmersResponse>
		<sqlState>22003 if number too large for target; 22001 otherwise.</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-303</code>
		<message><![CDATA[A VALUE CANNOT BE ASSIGNED TO OUTPUT HOST VARIABLE NUMBER position-number BECAUSE THE DATA TYPES ARE NOT COMPARABLE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify that table definitions are current and that the host variable has the correct data type.]]></programmersResponse>
		<sqlState>42806</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-304</code>
		<message><![CDATA[A VALUE WITH DATA TYPE data-type1 CANNOT BE ASSIGNED TO A HOST VARIABLE BECAUSE THE VALUE IS NOT WITHIN THE RANGE OF THE HOST VARIABLE IN POSITION position-number WITH DATA TYPE data-type2]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify that table definitions are current, and that the host variable has the correct data type. See the explanation for SQLCODE -405 for ranges of SQL data types.]]></programmersResponse>
		<sqlState>22003</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-305</code>
		<message><![CDATA[THE NULL VALUE CANNOT BE ASSIGNED TO OUTPUT HOST VARIABLE NUMBER position-number BECAUSE NO INDICATOR VARIABLE IS SPECIFIED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine the definition of the table that is the object of the statement and correct the application program to provide indicator variables for all host variables into which null values can be retrieved. This includes host variables for columns which can contain null values and host variables which receive the results of aggregate functions whose result table could be empty.]]></programmersResponse>
		<sqlState>22002</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-309</code>
		<message><![CDATA[A PREDICATE IS INVALID BECAUSE A REFERENCED HOST VARIABLE HAS THE NULL VALUE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Rebind the plan or package containing the statement. The condition described is not an error in DB2 Version 2 Release 3 and later releases.]]></programmersResponse>
		<sqlState>22512</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-310</code>
		<message><![CDATA[DECIMAL HOST VARIABLE OR PARAMETER number CONTAINS NON-DECIMAL DATA]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the application program or stored procedure. Ensure that all decimal variables or parameters contain valid System/370 packed decimal numbers.]]></programmersResponse>
		<sqlState>22023</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-311</code>
		<message><![CDATA[THE LENGTH OF INPUT HOST VARIABLE NUMBER position-number IS NEGATIVE OR GREATER THAN THE MAXIMUM]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the program to ensure that the lengths of all host string variables are not negative or that they are not greater than the maximum allowed length.]]></programmersResponse>
		<sqlState>22501</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-312</code>
		<message><![CDATA[variable-name IS AN UNDEFINED OR UNUSABLE HOST VARIABLE OR IS USED IN A DYNAMIC SQL STATEMENT OR A TRIGGER DEFINITION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify that

The variable name is spelled properly in the SQL statement.
The variable is allowed in the SQL statement.
The application program contains a declaration for that variable.
The attributes of the variable are compatible with its use in the statement.]]></programmersResponse>
		<sqlState>42618</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-313</code>
		<message><![CDATA[THE NUMBER OF HOST VARIABLES SPECIFIED IS NOT EQUAL TO THE NUMBER OF PARAMETER MARKERS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the application program so that the number of host variables specified in the EXECUTE or OPEN statement is the same as the number of parameter markers appearing in the prepared SQL statement. The DESCRIBE INPUT SQL statement can be used to determine the expected number of input parameter markers.]]></programmersResponse>
		<sqlState>07001</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-314</code>
		<message><![CDATA[THE STATEMENT CONTAINS AN AMBIGUOUS HOST VARIABLE REFERENCE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Make the host variable unique or use qualifications to indicate which host variable definition is to be used.]]></programmersResponse>
		<sqlState>42714</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-327</code>
		<message><![CDATA[THE ROW CANNOT BE INSERTED BECAUSE IT IS OUTSIDE THE BOUND OF THE PARTITION RANGE FOR THE LAST PARTITION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement to specify a value for the partition key that is within the bounds of the last partition of the partitioned table space.]]></programmersResponse>
		<sqlState>22525</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-330</code>
		<message><![CDATA[A STRING CANNOT BE USED BECAUSE IT CANNOT BE CONVERTED. REASON reason-code, CHARACTER code-point, HOST VARIABLE position-number]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Take one of the following actions based on the reason-code

If the reason-code is 8, extend the maximum length of the host variable to allow for the expansion that occurs when the string is converted.
If the reason-code is 12, either change the convert table to accept the code-point or the data to eliminate the code-point.
If the reason-code is 16 and the string is described as MIXED data, either change its description or the string to conform to the rules for well-formed mixed data.
If the reason-code is 20, correct the conversion procedure.
If the reason-code is 24, delete the SBCS character from the graphic string.]]></programmersResponse>
		<sqlState>22021</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-331</code>
		<message><![CDATA[CHARACTER CONVERSION CANNOT BE PERFORMED BECAUSE A STRING, POSITION position-number CANNNOT BE CONVERTED FROM source-ccsid TO target-ccsid, REASON reason-code]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Take one of the following actions based on the reason-code:
 - If the reason-code is 8, the maximum length of the result column must be extended to allow for the expansion that occurs when the string is converted.
 - If the reason-code is 12, either the conversion table must be changed to accept the code-point or the data must be changed to eliminate the code-point.
 - If the reason-code is 16, and the string is described as MIXED data, either its description must be changed or the string must be changed to conform to the rules for well-formed MIXED data.
 - If the reason-code is 20, the conversion procedure must be corrected.

An alternative to these corrective actions is to provide an indicator variable so that a null value and a warning can be returned rather than an error. Refer to Chapter 2 of DB2 SQL Reference for more information on coded character set.]]></programmersResponse>
		<sqlState>22021</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-332</code>
		<message><![CDATA[CHARACTER CONVERSION BETWEEN CCSID from-ccsid TO to-ccsid REQUESTED BY reason-code IS NOT SUPPORTED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If the conversion request is correct, refer to the section entitled &quot;Character conversion&quot; in DB2 Installation Guide for information on how to add conversion support.]]></programmersResponse>
		<sqlState>57017</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-333</code>
		<message><![CDATA[THE SUBTYPE OF A STRING VARIABLE IS NOT THE SAME AS THE SUBTYPE KNOWN AT BIND TIME AND THE DIFFERENCE CANNOT BE RESOLVED BY CHARACTER CONVERSION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the CCSID in the SQLDA so that the subtype of the host variable is consistent with the bind time subtype of the host variable or parameter marker. If the input data in error is a parameter marker, you can use the DESCRIBE INPUT SQL statement to determine the expected SQLTYPE, SQLLEN and CCSID expected. Refer to Chapter 2 of DB2 SQL Reference for more information on coded character set.]]></programmersResponse>
		<sqlState>56010</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-336</code>
		<message><![CDATA[THE SCALE OF THE DECIMAL NUMBER MUST BE ZERO]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the decimal number so that there are no non-zero digits to the right of the decimal point.]]></programmersResponse>
		<sqlState>428FA</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-338</code>
		<message><![CDATA[AN ON CLAUSE IS INVALID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the syntax so that it doesn't violate any of the above items within the ON clause]]></programmersResponse>
		<sqlState>42972</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-340</code>
		<message><![CDATA[THE COMMON TABLE EXPRESSION name HAS THE SAME IDENTIFIER AS ANOTHER OCCURRENCE OF A COMMON TABLE EXPRESSION DEFINITION WITHIN THE SAME STATEMENT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the error by changing the name of one of the common table expressions.]]></programmersResponse>
		<sqlState>42726</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-341</code>
		<message><![CDATA[A CYCLIC REFERENCE EXISTS BETWEEN THE COMMON TABLE EXPRESSIONS name1 AND name2]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Remove the cyclic reference from one of the common table expressions.]]></programmersResponse>
		<sqlState>42835</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-342</code>
		<message><![CDATA[THE COMMON TABLE EXPRESSION name MUST NOT USE SELECT DISTINCT AND MUST USE UNION ALL BECAUSE IT IS RECURSIVE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Remove the keyword DISTINCT from the common table expression, add the keyword ALL following UNION, or remove the recursive reference within the common table expression.]]></programmersResponse>
		<sqlState>42925</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-343</code>
		<message><![CDATA[THE COLUMN NAMES ARE REQUIRED FOR THE RECURSIVE COMMON TABLE EXPRESSION name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Add column names following the identifier of the common table expressions.]]></programmersResponse>
		<sqlState>42908</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-344</code>
		<message><![CDATA[THE RECURSIVE COMMON TABLE EXPRESSION name HAS MISMATCHED DATA TYPES OR LENGTHS FOR COLUMN column-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the column used in the fullselects of the recursive common table expression so that the initialization column matches the iterative columns.]]></programmersResponse>
		<sqlState>42825</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-345</code>
		<message><![CDATA[THE FULLSELECT OF THE RECURSIVE COMMON TABLE EXPRESSION name MUST BE THE UNION OF TWO OR MORE FULLSELECTS AND MUST NOT INCLUDE COLUMN FUNCTIONS, GROUP BY CLAUSE, HAVING CLAUSE, OR AN EXPLICIT JOIN INCLUDING AN ON CLAUSE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the common table expression by:
 - making it a union of two or more fullselects.
 - removing any column functions, GROUP BY clause, HAVING clause, or explicit JOIN including an ON clause.
 - removing the recursive reference.]]></programmersResponse>
		<sqlState>42836</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-346</code>
		<message><![CDATA[AN INVALID REFERENCE TO COMMON TABLE EXPRESSION name OCCURS IN THE FIRST FULLSELECT, AS A SECOND OCCURRENCE IN THE SAME FROM CLAUSE, OR IN THE FROM CLAUSE OF A SUBQUERY]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change one of the following:
 - the fullselect prior to the union operator so that it does not include a recursive reference.
 - the FROM clause containing more than one reference to the same common table expression to just one reference .
 - the FROM clause of the subquery so that it does not reference the common table expression.]]></programmersResponse>
		<sqlState>42836</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-348</code>
		<message><![CDATA[sequence-expression CANNOT BE SPECIFIED IN THIS CONTEXT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Remove the reference to the sequence expression and resubmit the statement.]]></programmersResponse>
		<sqlState>428F9</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-350</code>
		<message><![CDATA[INVALID SPECIFICATION OF A LARGE OBJECT COLUMN]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the syntax and resubmit the statement.]]></programmersResponse>
		<sqlState>42962</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-351</code>
		<message><![CDATA[AN UNSUPPORTED SQLTYPE WAS ENCOUNTERED IN POSITION position-number OF THE SELECT-LIST]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the statement to exclude the unsupported data type. For a select statement, remove the names of any columns in the select-list with the unsupported data types.]]></programmersResponse>
		<sqlState>56084</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-352</code>
		<message><![CDATA[AN UNSUPPORTED SQLTYPE WAS ENCOUNTERED IN POSITION position-number OF THE INPUT-LIST]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the SQLDA to exclude the unsupported data type.]]></programmersResponse>
		<sqlState>56084</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-353</code>
		<message><![CDATA[FETCH IS NOT ALLOWED, BECAUSE CURSOR cursor-name HAS AN UNKNOWN POSITION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Close and reopen the cursor to reset the cursor position. For scrollable cursors, you can change the FETCH statement to specify one of the other fetch orientations. For example, you can modify the FETCH statement by specifying one of the following fetch orientations:
 - BEFORE or AFTER
 - row-positioned fetch orientations: FIRST, LAST, or ABSOLUTE to establish a valid row cursor and fetch a row of data
 - rowset-positioned fetch orientations: FIRST ROWSET, LAST ROWSET, or ROWSET STARTING AT ABSOLUTE to establish a valid rowset cursor position and fetch multiple rows of data

Alternately, change the application to correct the error that originally occurred. For example, if the error was issued because an indicator was not provided, change the application to provide an indicator.]]></programmersResponse>
		<sqlState>24513</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-355</code>
		<message><![CDATA[A LOB COLUMN IS TOO LARGE TO BE LOGGED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Either change the attribute of the LOB table space to LOG NO or drop the base table, and recreate it with columns of an acceptable length for logging.]]></programmersResponse>
		<sqlState>42993</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-359</code>
		<message><![CDATA[THE RANGE OF VALUES FOR THE IDENTITY COLUMN OR SEQUENCE IS EXHAUSTED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Take one of the following actions:
 - For an identity column, redefine the table with a larger range of values for the identity column. If a MAXVALUE or MINVALUE specification has been made that limits the range of values to be less than the range for the data type of the column, then the column can be altered to expand the range of valid values. Otherwise, the identity column must be recreated, which requires that the table be recreated. First, drop the existing table; then, recreate the table with a different data type for the identity column, specifying a data type that has a larger range of values than the current data type for the identity column.
 - For a sequence object, redefine the sequence with a larger range of values. If a MAXVALUE or MINVALUE specification has been made that limits the range of values to be less than the range for the data type, then the sequence can be altered to expand the range of valid values. Otherwise, the sequence must be recreated using DROP SEQUENCE and CREATE SEQUENCE to cover a larger range of values.]]></programmersResponse>
		<sqlState>23522</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-372</code>
		<message><![CDATA[ONLY ONE ROWID OR IDENTITY COLUMN IS ALLOWED IN A TABLE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[For a CREATE TABLE statement, select only one column to have the row ID data type or the AS IDENTITY attribute. For an ALTER TABLE statement, a ROWID column or identity column already exists for the table. Do not attempt to add another column with the data type row ID or with the AS IDENTITY attribute to the table.]]></programmersResponse>
		<sqlState>428C1</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-373</code>
		<message><![CDATA[DEFAULT CANNOT BE SPECIFIED FOR IDENTITY COLUMN OR SECURITY LABEL columnname-seclabel]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Remove the DEFAULT clause and resubmit the statement.]]></programmersResponse>
		<sqlState>42623</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-390</code>
		<message><![CDATA[THE FUNCTION function-name, SPECIFIC NAME specific-name, IS NOT VALID IN THE CONTEXT IN WHICH IT OCCURS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure that the correct function name and arguments are specified and that the SQL path includes the schema where the correct function is defined. You may need to change the function name, arguments, SQL path (using SET CURRENT PATH or the PATH bind option), or change the context in which the function is used. Refer to Chapter 5 of DB2 SQL Reference for information on the use of functions.]]></programmersResponse>
		<sqlState>42887</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-392</code>
		<message><![CDATA[SQLDA PROVIDED FOR CURSOR cursor HAS BEEN CHANGED FROM THE PREVIOUS FETCH]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Either do not use DB2 rules, or change to application to not change the data type code from LOB to locator (or the reverse) in the SQLDA between successive fetches.]]></programmersResponse>
		<sqlState>42855</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-393</code>
		<message><![CDATA[THE CONDITION OR CONNECTION NUMBER IS INVALID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the value of the CONDITION or CONNECTION number, while ensuring that the number is between 1 and the value of the NUMBER statement-information item or GET DIAGNOSTICS. Resubmit the GET DIAGNOSTICS CONDITION or GET DIAGNOSTICS CONNECTION statement.]]></programmersResponse>
		<sqlState>35000</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-396</code>
		<message><![CDATA[object-type object-name ATTEMPTED TO EXECUTE AN SQL STATEMENT DURING FINAL CALL PROCESSING]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the definition of the function to not issue SQL statements during final call processing.]]></programmersResponse>
		<sqlState>38505</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-397</code>
		<message><![CDATA[GENERATED IS SPECIFIED WITH A COLUMN THAT IS NOT A ROW ID, A DISTINCT TYPE BASED ON A ROW ID, OR AN IDENTITY COLUMN]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement. Either eliminate the GENERATED clause or change the data type of the column ensure that the data type of the object is row ID, or that the column is an identity column]]></programmersResponse>
		<sqlState>428D3</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-398</code>
		<message><![CDATA[A LOCATOR WAS REQUESTED FOR HOST VARIABLE NUMBER position-number BUT THE VARIABLE IS NOT A LOB]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the statement to either return LOB data, or change the target host variable to not be a locator.]]></programmersResponse>
		<sqlState>428D2</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-399</code>
		<message><![CDATA[ATTEMPTED TO INSERT AN INVALID VALUE INTO A ROWID COLUMN]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Do not attempt to generate any value for insertion into a ROWID column. Insertion into ROWID columns is supported for purposes of Data Propagation, where DB2 has previously generated the row ID values. Only row ID values previously generated by DB2 can be used as values for insertion into a row ID column. Alternatively, insert the row specifying DEFAULT for the ROWID column or remove the ROWID column from the insert column-list.
You may also use the OVERRIDING clause as a possible solution for this situation. See INSERT in DB2 SQL Reference for more information about the OVERRIDING USER VALUE clause.]]></programmersResponse>
		<sqlState>22511</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-400</code>
		<message><![CDATA[THE CATALOG HAS THE MAXIMUM NUMBER OF USER DEFINED INDEXES]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If this index must be created, another user-defined index on the catalog must be dropped. After that index is dropped, this statement can be executed.]]></programmersResponse>
		<sqlState>54027</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-401</code>
		<message><![CDATA[THE OPERANDS OF AN ARITHMETIC OR COMPARISON OPERATION ARE NOT COMPARABLE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Check the data types of all operands to ensure that their data types are comparable and compatible with their usage in the statement.
If all the operands of the SQL statement are correct, then, if a view is being accessed, check the data types of all the operands in the view definition.]]></programmersResponse>
		<sqlState>42818</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-402</code>
		<message><![CDATA[AN ARITHMETIC FUNCTION OR OPERATOR arith-fop IS APPLIED TO CHARACTER OR DATETIME DATA]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine and correct the syntax of the SQL statement such that all operands of the specified function or operator are numeric.]]></programmersResponse>
		<sqlState>42819</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-404</code>
		<message><![CDATA[THE SQL STATEMENT SPECIFIES A STRING THAT IS TOO LONG]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Check the length of the target column, parameter, host variable or transition variable and correct the program or SQL statement so that the length of the string does not exceed that maximum. For example, you could use the SUBSTR function to shorten the string.]]></programmersResponse>
		<sqlState>22001</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-405</code>
		<message><![CDATA[THE NUMERIC LITERAL literal CANNOT BE USED AS SPECIFIED BECAUSE IT IS OUT OF RANGE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The value of literal should be reduced to the appropriate size for this data type.]]></programmersResponse>
		<sqlState>42820</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-406</code>
		<message><![CDATA[A CALCULATED OR DERIVED NUMERIC VALUE IS NOT WITHIN THE RANGE OF ITS OBJECT COLUMN]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[See the explanation of SQLCODE -405 for allowed ranges for numeric data types.]]></programmersResponse>
		<sqlState>22003</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-407</code>
		<message><![CDATA[AN UPDATE, INSERT, OR SET VALUE IS NULL, BUT THE OBJECT COLUMN column-name CANNOT CONTAIN NULL VALUES]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine the definition of the object table to determine which columns of the table have the NOT NULL attribute or have a type of ROWID, and correct the SQL statement accordingly.]]></programmersResponse>
		<sqlState>23502</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-408</code>
		<message><![CDATA[THE VALUE IS NOT COMPATIBLE WITH THE DATA TYPE OF ITS TARGET. TARGET NAME IS name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine the current definition for the object table, procedure, user-defined function, or host variable and ensure that the host variable or literal value that is assigned to the object has the proper data type. In some cases, you can convert the value to the proper data type by using a function such as CHAR or DECIMAL.]]></programmersResponse>
		<sqlState>42821</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-409</code>
		<message><![CDATA[INVALID OPERAND OF A COUNT FUNCTION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the syntax and resubmit the statement. Refer to Chapter 3 of DB2 SQL Reference for information about the proper form for the operands of a COUNT or COUNT_BIG function.]]></programmersResponse>
		<sqlState>42607</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-410</code>
		<message><![CDATA[THE FLOATING POINT LITERAL literal CONTAINS MORE THAN 30 CHARACTERS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the indicated literal.]]></programmersResponse>
		<sqlState>42820</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-411</code>
		<message><![CDATA[CURRENT SQLID CANNOT BE USED IN A STATEMENT THAT REFERENCES REMOTE OBJECTS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Either remove the reference to CURRENT SQLID or the reference to the remote object.]]></programmersResponse>
		<sqlState>56040</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-412</code>
		<message><![CDATA[THE SELECT CLAUSE OF A SUBQUERY SPECIFIES MULTIPLE COLUMNS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the syntax of the SQL statement. Refer to Chapter 4 of DB2 SQL Reference for information about restrictions on the syntax for subqueries.]]></programmersResponse>
		<sqlState>42823</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-413</code>
		<message><![CDATA[OVERFLOW OCCURRED DURING NUMERIC DATA TYPE CONVERSION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine the syntax of the SQL statement to determine the cause of the error. If the problem is data-dependent, it might be necessary to examine the data processed at the time of the error.]]></programmersResponse>
		<sqlState>22003</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-414</code>
		<message><![CDATA[A LIKE PREDICATE IS INVALID BECAUSE THE FIRST OPERAND IS NOT A STRING]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Respecify the predicate so that the data type of each operand is a character string or a graphic string.]]></programmersResponse>
		<sqlState>42824</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-415</code>
		<message><![CDATA[THE CORRESPONDING COLUMNS, column-number, OF THE OPERANDS OF A UNION OR A UNION ALL DO NOT HAVE COMPARABLE COLUMN DESCRIPTIONS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Check the data types of the specified columns and correct the UNION or UNION ALL statement so that all corresponding columns have comparable column descriptions.]]></programmersResponse>
		<sqlState>42825</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-416</code>
		<message><![CDATA[AN OPERAND OF A UNION CONTAINS A LONG STRING COLUMN]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The implied function is not supported by DB2. Refer to Chapter 2 of DB2 SQL Reference for information about restrictions on the manipulation of long string columns.]]></programmersResponse>
		<sqlState>42907</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-417</code>
		<message><![CDATA[A STATEMENT STRING TO BE PREPARED INCLUDES PARAMETER MARKERS AS THE OPERANDS OF THE SAME OPERATOR]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the logic of the application program so that this syntax error does not occur. Refer to Chapter 5 of DB2 SQL Reference for information about the proper usage of parameter markers within SQL statements to be prepared.]]></programmersResponse>
		<sqlState>42609</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-418</code>
		<message><![CDATA[A STATEMENT STRING TO BE PREPARED CONTAINS AN INVALID USE OF PARAMETER MARKERS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the logic of the application program so that this error does not occur. Refer to Chapter 5 of DB2 SQL Reference for information about the proper usage of parameter markers within SQL statements and for EXECUTE IMMEDIATE SQL statement restrictions.]]></programmersResponse>
		<sqlState>42610</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-419</code>
		<message><![CDATA[THE DECIMAL DIVIDE OPERATION IS INVALID BECAUSE THE RESULT WOULD HAVE A NEGATIVE SCALE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine the precision and scale of all columns that may have participated in a decimal division. Note that an integer or small integer value may have been converted to decimal for this calculation.]]></programmersResponse>
		<sqlState>42911</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-420</code>
		<message><![CDATA[THE VALUE OF A STRING ARGUMENT WAS NOT ACCEPTABLE TO THE function-name FUNCTION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the argument value so that it conforms to the requirements of the function as specified in DB2 SQL Reference.]]></programmersResponse>
		<sqlState>22018</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-421</code>
		<message><![CDATA[THE OPERANDS OF A UNION OR UNION ALL DO NOT HAVE THE SAME NUMBER OF COLUMNS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the SQL statement so that there are exactly the same number of columns in each operand.]]></programmersResponse>
		<sqlState>42826</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-423</code>
		<message><![CDATA[INVALID VALUE FOR LOCATOR IN POSITION position-]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[For a result set locator there are two common causes for the error:
 - The host variable used as a result set locator was never assigned a valid result set locator value. Result set locator values are returned by the DESCRIBE PROCEDURE and ASSOCIATE LOCATORS statements. Make sure the value in your host variable is obtained from one of these statements. Result set locator values are only valid as long as the underlying SQL cursor is open. If a commit or rollback operation closes an SQL cursor, the result set locator associated with the cursor is no longer valid.

For a LOB locator, some common causes for the error are:
 - The host variable used as a LOB locator was never assigned a valid LOB value. A commit or rollback operation or an SQL FREE LOCATOR statement freed the locator.

For a table locator, the error commonly occurs when the host variable that was used as a table locator was never assigned a valid table locator value.]]></programmersResponse>
		<sqlState>0F001</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-426</code>
		<message><![CDATA[DYNAMIC COMMIT NOT VALID AT AN APPLICATION SERVER WHERE UPDATES ARE NOT ALLOWED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The IMS or CICS protocols should be used to commit work in these environments.]]></programmersResponse>
		<sqlState>2D528</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-427</code>
		<message><![CDATA[DYNAMIC ROLLBACK NOT VALID AT AN APPLICATION SERVER WHERE UPDATES ARE NOT ALLOWED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The IMS or CICS protocols should be used to rollback work in these environments.]]></programmersResponse>
		<sqlState>2D529</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-430</code>
		<message><![CDATA[routine-type routine-name (SPECIFIC NAME specific-name) HAS ABNORMALLY TERMINATED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The stored procedure or function needs to be fixed. Contact the author of the routine or your database administrator. Until it is fixed, the routine should not be used.]]></programmersResponse>
		<sqlState>38503</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-433</code>
		<message><![CDATA[VALUE value IS TOO LONG]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If value is a literal string in the SQL statement, it is too long for its intended use. If value is not a literal string, examine the SQL statement to determine where the transformation is taking place. Either the input to the transformation is too long, or the target is too short. Correct the problem and rerun the statement.]]></programmersResponse>
		<sqlState>22001</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-435</code>
		<message><![CDATA[AN INVALID SQLSTATE sqlstate IS SPECIFIED IN THE FUNCTION RAISE_ERROR OR IN A SIGNAL OR RESIGNAL SQLSTATE STATEMENT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the SQLSTATE specified in the RAISE_ERROR function or SIGNAL or RESIGNAL statement. The SQLSTATE must be a character string containing exactly 5 characters. It must be of type CHAR defined with a length of 5, or a type VARCHAR defined with a length of 5 or greater. The SQLSTATE value must follow the rules for application-defined SQLSTATEs as follows:
 - Each character must be from the set of digits ('0' through '9') or non-accented upper case letters ('A' through 'Z').
 - The SQLSTATE class (first two characters) cannot be '00', '01' or '02' because these are not error classes.
 - If the SQLSTATE class (first two characters) starts with the character '0' through '6' or 'A' through 'H', then the subclass (last three characters) must start with a letter in the range 'I' through 'Z'.
 - If the SQLSTATE class (first two characters) starts with the character '7', '8', '9' or 'I' though 'Z', then the subclass (last three characters) can be any of '0' through '9' or 'A' through 'Z'.]]></programmersResponse>
		<sqlState>428B3</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-438</code>
		<message><![CDATA[APPLICATION RAISED ERROR WITH DIAGNOSTIC TEXT: text]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Use application-provided diagnostic text, if provided, to determine the cause of the error.]]></programmersResponse>
		<sqlState>application-defined</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-440</code>
		<message><![CDATA[NO routine-type BY THE NAME routine-name HAVING COMPATIBLE ARGUMENTS WAS FOUND]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Fix the problem and retry. This could involve a change to the SQL statement, the addition of new routines or a change to the user's SQL path.]]></programmersResponse>
		<sqlState>42884</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-441</code>
		<message><![CDATA[INVALID USE OF 'DISTINCT' OR 'ALL' WITH SCALAR FUNCTION function-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If a scalar function is being used, then remove the keyword 'DISTINCT' or 'ALL'.
If an aggregate function is being used, then there is a problem with function resolution. Check your SQL path to see if the desired function is in one of the schemas, and also check the SYSIBM.SYSROUTINES catalog for the spelling of the function name and the number and types of parameters.]]></programmersResponse>
		<sqlState>42601</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-443</code>
		<message><![CDATA[ROUTINE routine-name (SPECIFIC NAME specific-name) HAS RETURNED AN ERROR SQLSTATE WITH DIAGNOSTIC TEXT msg-text]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Contact the author of the function or your database administrator. Until the problem is resolved, the function should not be used.]]></programmersResponse>
		<sqlState>38xxx (the SQLSTATE that was returned by the routine).</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-444</code>
		<message><![CDATA[USER PROGRAM name COULD NOT BE FOUND]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If the EXTERNAL_NAME column value in the SYSIBM.SYSROUTINES table is incorrect, use the ALTER FUNCTION or ALTER PROCEDURE statement to correct the value.
If the EXTERNAL_NAME column value is correct, use the MVS linkage editor to create the required MVS load module in one of the MVS load libraries used by your installation for stored procedures.
This error can also occur if you are invoking a WLM-managed stored procedure that is not APF authorized, and the DB2 load libraries are not in the STEPLIB concatenation because they are being loaded from LINKLIST. In this case, if you want the stored procedure program to run APF-authorized, link-edit it with AC=1 into an MVS APF authorized library. If you do not want the stored procedure program to run APF authorized, add the DB2 load library to the STEPLIB concatenation of the JCL used to start the WLM-managed address space.]]></programmersResponse>
		<sqlState>42724</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-449</code>
		<message><![CDATA[CREATE OR ALTER STATEMENT FOR FUNCTION OR PROCEDURE routine-name CONTAINS AN INVALID FORMAT OF THE EXTERNAL NAME CLAUSE OR IS MISSING THE EXTERNAL NAME CLAUSE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the syntax of the SQL statement. Refer to the DB2 SQL Reference for information on the EXTERNAL NAME clause.
User Response: When LANGUAGE is JAVA or COMPJAVA, possible causes include:
 - Omitting hte EXTERNAL NAME clause.
 - Including a blank.
 - Having the '!' at the beginning or end of the name.
 - Specifying an invalid external-java-routine-name.]]></programmersResponse>
		<sqlState>42878</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-450</code>
		<message><![CDATA[USER-DEFINED FUNCTION OR STORED PROCEDURE name, PARAMETER NUMBER parmnum, OVERLAYED STORAGE BEYOND ITS DECLARED LENGTH.]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Contact the author of the function or your database administrator. Until it is fixed, the function should not be used.]]></programmersResponse>
		<sqlState>39501</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-451</code>
		<message><![CDATA[THE data-item DEFINITION, IN THE CREATE FUNCTION FOR function-name CONTAINS DATA TYPE type WHICH IS NOT APPROPRIATE FOR AN EXTERNAL FUNCTION WRITTEN IN THE GIVEN LANGUAGE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement.]]></programmersResponse>
		<sqlState>42815</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-453</code>
		<message><![CDATA[THERE IS A PROBLEM WITH THE RETURNS CLAUSE IN THE CREATE FUNCTION STATEMENT FOR function-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the RETURNS or CAST FROM clause so that the CAST FROM data type is castable to the RETURNS data type.]]></programmersResponse>
		<sqlState>42880</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-454</code>
		<message><![CDATA[THE SIGNATURE PROVIDED IN THE CREATE FUNCTION STATEMENT FOR function-name MATCHES THE SIGNATURE OF SOME OTHER FUNCTION ALREADY EXISTING IN THE SCHEMA]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Determine if the existing function already provides the functionality desired. If not, then the new function's signature will have to be changed (e.g. change the function name).]]></programmersResponse>
		<sqlState>42723</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-455</code>
		<message><![CDATA[IN CREATE FUNCTION FOR function-name, THE SCHEMA NAME schema-name1 PROVIDED FOR THE SPECIFIC NAME DOES NOT MATCH THE SCHEMA NAME schema-name2 OF THE FUNCTION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement.]]></programmersResponse>
		<sqlState>42882</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-456</code>
		<message><![CDATA[IN CREATE FUNCTION FOR function-name, THE SPECIFIC NAME specific-name ALREADY EXISTS IN THE SCHEMA]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Choose a new SPECIFIC name.]]></programmersResponse>
		<sqlState>42710</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-457</code>
		<message><![CDATA[A FUNCTION OR DISTINCT TYPE CANNOT BE CALLED name SINCE IT IS RESERVED FOR SYSTEM USE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Select a name for the function or distinct type that is not reserved for system use.]]></programmersResponse>
		<sqlState>42939</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-458</code>
		<message><![CDATA[IN A REFERENCE TO FUNCTION function-name BY SIGNATURE, A MATCHING FUNCTION COULD NOT BE FOUND]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Possible responses include:
 - Changing the SQL path to include the correct schema. Changing the attibutes of the parameters. Using a SPECIFIC name to refer to the function instead of a signature.]]></programmersResponse>
		<sqlState>42883</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-461</code>
		<message><![CDATA[A VALUE WITH DATA TYPE source-data-type CANNOT BE CAST TO TYPE target-data-type]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the CAST specification to specify a supported combination of source and target types.]]></programmersResponse>
		<sqlState>42846</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-469</code>
		<message><![CDATA[SQL CALL STATEMENT MUST SPECIFY AN OUTPUT HOST VARIABLE FOR PARAMETER number]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If the SQL CALL statement is coded incorrectly, modify the SQL application to provide an output host variable on the SQL CALL statement.
If the SYSIBM.SYSPARMS table contains incorrect information, the DROP PROCEDURE and CREATE PROCEDURE statements must be used to replace the catalog definition for the stored procedure.]]></programmersResponse>
		<sqlState>42886</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-470</code>
		<message><![CDATA[SQL CALL STATEMENT SPECIFIED A NULL VALUE FOR INPUT PARAMETER number, BUT THE STORED PROCEDURE DOES NOT SUPPORT NULL VALUES.]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If the stored procedure should not accept null values, change the calling application to provide a nonnull value.
If the stored procedure should accept null values, use the ALTER PROCEDURE statement to change the PARAMETER STYLE of the stored procedure to be DB2SQL or GENERAL WITH NULLS.]]></programmersResponse>
		<sqlState>39004</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-471</code>
		<message><![CDATA[INVOCATION OF FUNCTION OR PROCEDURE name FAILED DUE TO REASON rc]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the condition described by the DB2 reason code.]]></programmersResponse>
		<sqlState>55023</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-472</code>
		<message><![CDATA[CURSOR cursor-name WAS LEFT OPEN BY EXTERNAL FUNCTION function-name (SPECIFIC NAME specific-name)]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Reissue the statement when desired.]]></programmersResponse>
		<sqlState>24517</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-473</code>
		<message><![CDATA[A USER DEFINED DATA TYPE CANNOT BE CALLED THE SAME NAME AS A SYSTEM PREDEFINED TYPE (BUILT-IN TYPE)]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement to use another identifier for the name of the new user-defined type.]]></programmersResponse>
		<sqlState>42918</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-475</code>
		<message><![CDATA[THE RESULT TYPE type-1 OF THE SOURCE FUNCTION CANNOT BE CAST TO THE RETURNS TYPE type-2 OF THE USER-DEFINED FUNCTION function-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the RETURNS data type or the SOURCE function identified so that the result type of the SOURCE function is castable to the RETURNS data type.]]></programmersResponse>
		<sqlState>42866</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-476</code>
		<message><![CDATA[REFERENCE TO FUNCTION function-name WAS NAMED WITHOUT A SIGNATURE, BUT THE FUNCTION IS NOT UNIQUE WITHIN ITS SCHEMA]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the reference by one of the following:
 - completing the signature using the SPECIFIC name of the desired function changing the SQL path]]></programmersResponse>
		<sqlState>42725</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-478</code>
		<message><![CDATA[DROP OR REVOKE ON OBJECT TYPE type1 CANNOT BE PROCESSED BECAUSE OBJECT name OF TYPE type2 IS DEPENDENT ON IT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Remove the dependencies on this object and then reissue the request.]]></programmersResponse>
		<sqlState>42893</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-480</code>
		<message><![CDATA[THE PROCEDURE procedure-name HAS NOT YET BEEN CALLED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statements so that the exact syntax used to specify the procedure name on the CALL statement be the same as that on the ASSOCIATE LOCATOR and/or DESCRIBE PROCEDURE. If an unqualified name is used to CALL the procedure, the 1-part name must also be used on the other statements. If the CALL statement is made with a 3-part name, and the current server is the same as the location in the 3-part name, the ASSOCIATE LOCATOR or DESCRIBE procedure can omit the location. Rerun the statements.]]></programmersResponse>
		<sqlState>51030</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-482</code>
		<message><![CDATA[THE PROCEDURE procedure-name RETURNED NO LOCATORS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Determine if result set locators are returned from the identified procedure by using the DESCRIBE PROCEDURE statement.]]></programmersResponse>
		<sqlState>51030</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-483</code>
		<message><![CDATA[IN CREATE FUNCTION FOR function-name STATEMENT, THE NUMBER OF PARAMETERS DOES NOT MATCH THE NUMBER OF PARAMETERS OF THE SOURCE FUNCTION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The number of parameters for the SOURCE function and for the function being created must be the same. The identification of the SOURCE function needs to be changed to:
 - fix the input parameter list correct the function name or function specific name to identify the proper function.

It is also possible that the SQL path needs to be corrected in order for correct function resolution to occur.]]></programmersResponse>
		<sqlState>42885</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-487</code>
		<message><![CDATA[object-type object-name ATTEMPTED TO EXECUTE AN SQL STATEMENT WHEN THE DEFINITION OF THE FUNCTION OR PROCEDURE DID NOT SPECIFY THIS ACTION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Either use an ALTER statement to change the definition of the function or procedure to allow SQL statements, or remove the failing SQL statement from the external function or procedure.]]></programmersResponse>
		<sqlState>38001</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-490</code>
		<message><![CDATA[NUMBER number DIRECTLY SPECIFIED IN AN SQL STATEMENT IS OUTSIDE THE RANGE OF ALLOWABLE VALUES IN THIS CONTEXT (minval, maxval)]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the value n to a valid value in the statement.]]></programmersResponse>
		<sqlState>428B7</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-491</code>
		<message><![CDATA[CREATE STATEMENT FOR USER-DEFINED FUNCTION function-name MUST HAVE A RETURNS CLAUSE AND: THE EXTERNAL CLAUSE WITH OTHER REQUIRED KEYWORDS; THE RETURN STATEMENT AND PARAMETER NAMES; OR THE SOURCE CLAUSE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Add the missing clauses or statement, and reissue the failing statement.]]></programmersResponse>
		<sqlState>42601</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-492</code>
		<message><![CDATA[THE CREATE FUNCTION FOR function-name HAS A PROBLEM WITH PARAMETER NUMBER number. IT MAY INVOLVE A MISMATCH WITH A SOURCE FUNCTION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Possible corrections include:
 - Identify a different source function.
 - Change the data type of the parameter of the function being created so that the data type of the source function can be cast to this data type.]]></programmersResponse>
		<sqlState>42879</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-495</code>
		<message><![CDATA[ESTIMATED PROCESSOR COST OF estimate-amount1 PROCESSOR SECONDS (estimate-amount2 SERVICE UNITS) IN COST CATEGORY cost-category EXCEEDS A RESOURCE LIMIT ERROR THRESHOLD OF limit- amount SERVICE UNITS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If this SQLCODE was returned because the cost category value is &quot;B,&quot; it might be that the statement is using parameter markers or that some statistics are not available for the referenced tables and columns. Make sure the administrator has run the utility RUNSTATS on the referenced tables. It might also be that UDFs will be invoked when the statement is executed, or for INSERT, UPDATE, or DELETE statements that triggers are defined on the changed table. Check the DSN_STATEMNT_TABLE or the IFCID 22 record for this statement to find the reasons this SQL statement has been put in cost category &quot;B.&quot; If the program cannot be changed, or if statistics cannot be obtained, ask the administrator to change the value in the RLF_CATEGORY_B column in the RLST to &quot;Y&quot; which allows the statement to execute or &quot;W&quot; which returns a warning instead of an error.
User Response: If the warning is caused by an SQL statement that is consuming too much processor resource, attempt to rewrite the statement to perform more efficiently. Another option is to ask the administrator to increase the error threshold value in the RLST.]]></programmersResponse>
		<sqlState>57051</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-496</code>
		<message><![CDATA[THE SQL STATEMENT CANNOT BE EXECUTED BECAUSE IT REFERENCES A RESULT SET THAT WAS NOT CREATED BY THE CURRENT SERVER]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Connect to the server that called the stored procedure which created the result set before running the SQL statement that failed.]]></programmersResponse>
		<sqlState>51033</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-497</code>
		<message><![CDATA[THE MAXIMUM LIMIT OF INTERNAL IDENTIFIERS HAS BEEN EXCEEDED FOR DATABASE database-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Take the appropriate action as described in the following cases:
 - In the case of a DBID limit being exceeded, DROP all unused databases and issue a COMMIT.
 - In the case of an OBID limit being exceeded, DROP all unused objects in the database and issue a COMMIT, specify a different database or run the MODIFY utility to reclaim unused OBIDs.]]></programmersResponse>
		<sqlState>54041</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-499</code>
		<message><![CDATA[CURSOR cursor-name HAS ALREADY BEEN ASSIGNED TO THIS OR ANOTHER RESULT SET FROM PROCEDURE procedure-name.]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Determine if the target result set named in the ALLOCATE CURSOR statement has been previously assigned to a cursor.
If the result set has been previously assigned to cursor cursor-name, then either choose another target result set or call stored procedure procedure-name again and reissue the ASSOCIATE LOCATOR and ALLOCATE CURSOR statements.
If the result set has not been previously assigned to a cursor, the cursor cursor-name specified in the ALLOCATE CURSOR statement has been previously assigned to some result set from stored procedure procedure-name. You can not assign cursor cursor-name to another result set, so you must specify a different cursor name in the ALLOCATE CURSOR statement.
Correct the statements so that the exact syntax used to specify the procedure name on the CALL statement be the same as that on the ASSOCIATE LOCATOR and/or DESCRIBE PROCEDURE. If an unqualified name is used to CALL the procedure, the 1-part name must also be used on the other statements. If the CALL statement is made with a 3-part name, and the current server is the same as the location in the 3-part name, the ASSOCIATE LOCATOR or DESCRIBE procedure can omit the location.]]></programmersResponse>
		<sqlState>24516</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-500</code>
		<message><![CDATA[THE IDENTIFIED CURSOR WAS CLOSED WHEN THE CONNECTION WAS DESTROYED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The correction depends on the desired state of both the cursor and the connection, as follows:
 - If you want the cursor closed, change the application program so that the cursor is not referenced in the closed state.
 - If you want the cursor open and the connection was placed in the released state by the application program, change the program so that the connection is not placed in the released state until the cursor is explicitly closed.
 - If you want the cursor open and the connection was placed in the released state as a result of the DISCONNECT(AUTOMATIC) option, rebind the plan using DISCONNECT(CONDITIONAL).

Correct the error in the application, rebind the plan, and resubmit the job.]]></programmersResponse>
		<sqlState>24501</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-501</code>
		<message><![CDATA[THE CURSOR IDENTIFIED IN A FETCH OR CLOSE STATEMENT IS NOT OPEN]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Check for a previous SQL return code that may have closed the cursor. Commit and rollback operations close cursors. SQLCODES -404, -652, -679, -802, -901, -904, -909, -910, -911, -913, and -952 may force the cursor to close. After the cursor is closed, any fetches or close cursor statements will receive this SQLCODE -501.
If no previous SQL return codes have been issued, correct the logic of the application program to ensure that the cursor is open at the time the FETCH or CLOSE statement is executed.]]></programmersResponse>
		<sqlState>24501</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-502</code>
		<message><![CDATA[THE CURSOR IDENTIFIED IN AN OPEN STATEMENT IS ALREADY OPEN]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the logic of the application program to ensure that it does not attempt to execute an OPEN statement for a cursor that is already open.]]></programmersResponse>
		<sqlState>24502</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-503</code>
		<message><![CDATA[A COLUMN CANNOT BE UPDATED BECAUSE IT IS NOT IDENTIFIED IN THE UPDATE CLAUSE OF THE SELECT STATEMENT OF THE CURSOR]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the application program. If the column is to be updated, its name must be added to the FOR UPDATE clause of the cursor declaration.]]></programmersResponse>
		<sqlState>42912</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-504</code>
		<message><![CDATA[THE CURSOR NAME cursor-name IS NOT DEFINED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Check the application program for completeness and for a possible spelling error in the cursor declaration or allocation. The declaration for or allocation of a cursor must appear in an application program before SQL statements that reference the cursor.
If the cursor-name was &lt;UNKNOWN&gt;, then the cursor was not successfully declared or allocated. This can occur if SQL(DB2) was used, and a warning message was issued during precompilation. Check the precompile output for warning messages on the DECLARE CURSOR or ALLOCATE CURSOR statement, and correct the statement.
For an allocated cursor, if an implicit or explicit COMMIT, ROLLBACK, or CLOSE occurred since the cursor was successfully allocated, modify the application program logic to do one of the following:
 - After the COMMIT, ROLLBACK, or CLOSE operation, call the associated stored procedure again, and reissue the ASSOCIATE LOCATORS and ALLOCATE CURSOR statements.
 - For COMMIT, declare the associated cursor in the stored procedure WITH HOLD so the COMMIT operation will not deallocate the cursor.

For an allocated cursor, if the associated stored procedure was called again and new result sets were returned since the cursor was allocated, reissue the ASSOCIATE LOCATORS and ALLOCATE CURSOR statements.]]></programmersResponse>
		<sqlState>34000</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-507</code>
		<message><![CDATA[THE CURSOR IDENTIFIED IN THE UPDATE OR DELETE STATEMENT IS NOT OPEN]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Check for a previous SQL return code that might have closed the cursor. SQLCODES -404, -652, -679,-802, -901, -904, -909, -910, -911, -913, and -952 may force the cursor to close. After the cursor is closed, any fetches or close cursor statements receive SQLCODE -501. Any updates or deletes receive this SQLCODE -507. Correct the logic of the application program to ensure that the specified cursor is open at the time the UPDATE or DELETE statement is executed.]]></programmersResponse>
		<sqlState>24501</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-508</code>
		<message><![CDATA[THE CURSOR IDENTIFIED IN THE UPDATE OR DELETE STATEMENT IS NOT POSITIONED ON A ROW OR ROWSET THAT CAN BE UPDATED OR DELETED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the logic of the application program to ensure that the cursor is correctly positioned on the intended row of the object table before the UPDATE or DELETE statement is executed. Note that the cursor is not positioned on a row if FETCH returned an SQLCODE = 100.]]></programmersResponse>
		<sqlState>24504</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-509</code>
		<message><![CDATA[THE TABLE IDENTIFIED IN THE UPDATE OR DELETE STATEMENT IS NOT THE SAME TABLE DESIGNATED BY THE CURSOR]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the application program to ensure that the table identified in the UPDATE or DELETE statement is the same table identified in the declaration for the cursor.]]></programmersResponse>
		<sqlState>42827</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-510</code>
		<message><![CDATA[THE TABLE DESIGNATED BY THE CURSOR OF THE UPDATE OR DELETE STATEMENT CANNOT BE MODIFIED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The requested UPDATE or DELETE cannot be performed. Refer to Chapter 5 of DB2 SQL Reference for information about restrictions on using UPDATE and DELETE operations against views.
For a remote table, modify the DECLARE CURSOR and then rebind the PLAN.
For a cursor that uses parallelism, disable parallelism for the query by using the DEGREE(1) BIND option for static SQL or by setting the CURRENT DEGREE special register to '1' for dynamic SQL.
For an ambiguous cursor in an application bound CURRENTDATA(NO), either make the cursor unambiguous (declare it FOR UPDATE OF), or rebind the application CURRENTDATA(YES).]]></programmersResponse>
		<sqlState>42828</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-511</code>
		<message><![CDATA[THE FOR UPDATE CLAUSE CANNOT BE SPECIFIED BECAUSE THE TABLE DESIGNATED BY THE CURSOR CANNOT BE MODIFIED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Updates cannot be performed on the result table as it is specified. Refer to Chapter 5 of DB2 SQL Reference for information about restrictions on the updating of views.]]></programmersResponse>
		<sqlState>42829</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-512</code>
		<message><![CDATA[STATEMENT REFERENCE TO REMOTE OBJECT IS INVALID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If the object cannot be meaningfully eliminated from the statement, see your Database Administrator for other ways to obtain the data required. Refer to Chapter 3 of DB2 SQL Reference for more information about using remote objects.
If the remote object reference is in a triggered SQL statement, you can instead invoke a user-defined function or a stored procedure from the trigger and access the remote object from the function or stored procedure.]]></programmersResponse>
		<sqlState>56023</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-513</code>
		<message><![CDATA[THE ALIAS alias-name MUST NOT BE DEFINED ON ANOTHER LOCAL OR REMOTE ALIAS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Modify the SQL statement to ensure that all object references are to base tables or views.]]></programmersResponse>
		<sqlState>42924</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-514</code>
		<message><![CDATA[THE CURSOR cursor-name IS NOT IN A PREPARED STATE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[For case (1), ensure that you prepare the statement that is named in the DECLARE CURSOR statement for 'cursor-name' before you try to open the cursor. For case (2), do one of the following:
 - Use the WITH HOLD option of DECLARE CURSOR.
 - Do not execute a commit or rollback operation until you are finished using the cursor.
 - Prepare the statement again after the commit or rollback.]]></programmersResponse>
		<sqlState>26501</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-516</code>
		<message><![CDATA[THE DESCRIBE FOR STATIC STATEMENT DOES NOT IDENTIFY A PREPARED STATEMENT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the logic of the application program to ensure that a statement is properly prepared before a DESCRIBE FOR STATIC of the statement is attempted. If the DESCRIBE FOR STATIC is a distributed request that originated on a system that supports extended dynamic SQL, contact your system administrator about changing the DB2 subsystem parameter DESCSTAT to YES to tolerate these DESCRIBE FOR STATIC requests against static SQL.]]></programmersResponse>
		<sqlState>26501</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-517</code>
		<message><![CDATA[CURSOR cursor-name CANNOT BE USED BECAUSE ITS STATEMENT NAME DOES NOT IDENTIFY A PREPARED SELECT STATEMENT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify that the statement-name is specified correctly in the PREPARE statement and the DECLARE CURSOR statement for cursor 'cursor-name'. Alternatively, correct the application program logic to ensure that only prepared SELECT statements are used in association with cursor declarations.]]></programmersResponse>
		<sqlState>07005</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-518</code>
		<message><![CDATA[THE EXECUTE STATEMENT DOES NOT IDENTIFY A VALID PREPARED STATEMENT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure that you prepare the statement prior to EXECUTE. Also, ensure that the statement you prepare is not a SELECT or VALUES INTO statement.]]></programmersResponse>
		<sqlState>07003</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-519</code>
		<message><![CDATA[THE PREPARE STATEMENT IDENTIFIES THE SELECT STATEMENT OF THE OPENED CURSOR cursor-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the logic of the application program so that it does not attempt to re-PREPARE the SELECT statement for a cursor when that cursor is open.]]></programmersResponse>
		<sqlState>24506</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-525</code>
		<message><![CDATA[THE SQL STATEMENT CANNOT BE EXECUTED BECAUSE IT WAS IN ERROR AT BIND TIME FOR SECTION = sectno PACKAGE = pkgname CONSISTENCY TOKEN = contoken]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If the SQL statement is not supposed to execute at the indicated location, then correct the program so that the statement in error does not execute at that location. Precompile, compile, and bind replace the package. If the SQL statement is supposed to execute at the indicated location, correct the problem found when it was bound and bind the package over using BIND with ACTION(REPLACE). If multiple versions of the package have been bound, issue the following SELECT statement to determine which version has the error: SELECT VERSION FROM locid.SYSIBM.SYSPACKAGE WHERE LOCATION = ' ' AND COLLID = 'collid' AND NAME = 'pkgid' AND HEX(CONTOKEN) = 'contoken'
Where:
 - locid Location name
 - collid Collection id
 - pkgid Program name]]></programmersResponse>
		<sqlState>51015</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-526</code>
		<message><![CDATA[THE REQUESTED OPERATION OR USAGE DOES NOT APPLY TO table-type TEMPORARY TABLE table-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Modify the SQL statement to ensure that the object references are not to the indicated type of temporary table, or if table-type is DECLARED and you intended table-name to refer to an existing persistent base table, you must perform one of the following actions:
 - Recreate the persistent base table table-name with a different qualifier
 - In the same application process, issue a DROP TABLE for table name followed by a COMMIT to drop the declared temporary table and afterwards be able to reference the persistent base table with the same table-name in the same application process
 - Remove the DECLARE GLOBAL TEMPORARY TABLE statement from the application process to use the persistent base table with the same table-name]]></programmersResponse>
		<sqlState>42995</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-530</code>
		<message><![CDATA[THE INSERT OR UPDATE VALUE OF FOREIGN KEY constraint-name IS INVALID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine the insert or update value of the foreign key first, and then compare it with each of the parent keyvalues of the parent table to determine the cause of the problem.]]></programmersResponse>
		<sqlState>23503</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-531</code>
		<message><![CDATA[PARENT KEY IN A PARENT ROW CANNOT BE UPDATED BECAUSE IT HAS ONE OR MORE DEPENDENT ROWS IN RELATIONSHIP constraint-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine the parent key of the object table and the foreign key of the dependent table to determine if the value of the specified row of the parent keyshould be changed. If this does not expose the problem, examine the contents of the object table and the dependent table to determine the cause of the problem.]]></programmersResponse>
		<sqlState>23504</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-532</code>
		<message><![CDATA[THE RELATIONSHIP constraint-name RESTRICTS THE DELETION OF ROW WITH RID X'rid-number']]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine the delete rule for all descendent tables to determine the cause of the problem. The specific tables involved can be determined from the relationship 'constraint-name'. The specific descendent row is known by RID X'rid-number'.]]></programmersResponse>
		<sqlState>23504</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-533</code>
		<message><![CDATA[INVALID MULTIPLE-ROW INSERT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine the search condition of the subselect to make sure that no more than one row of data is selected.]]></programmersResponse>
		<sqlState>21501</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-534</code>
		<message><![CDATA[THE PRIMARY KEY CANNOT BE UPDATED BECAUSE OF MULTIPLE-ROW UPDATE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine the search condition of the UPDATE statement to make sure that no more than one row of the object table is selected to be updated.]]></programmersResponse>
		<sqlState>21502</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-536</code>
		<message><![CDATA[THE DELETE STATEMENT IS INVALID BECAUSE TABLE table-name CAN BE AFFECTED BY THE OPERATION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Do not attempt to reference a table in a subquery of a DELETE statement when the table can be affected by the DELETE statement.]]></programmersResponse>
		<sqlState>42914</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-537</code>
		<message><![CDATA[THE PRIMARY KEY, FOREIGN KEY, UNIQUE, OR PARTITIONING CLAUSE IDENTIFIES COLUMN column-name MORE THAN ONCE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement to specify unique names for each column.]]></programmersResponse>
		<sqlState>42709</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-538</code>
		<message><![CDATA[FOREIGN KEY name DOES NOT CONFORM TO THE DESCRIPTION OF A PARENT KEY OF TABLE table-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement so that the description of the foreign key references a primary key or unique key, or so that the description of the foreign key conforms to that of a parent key of the indicated table.]]></programmersResponse>
		<sqlState>42830</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-539</code>
		<message><![CDATA[TABLE table-name DOES NOT HAVE A PRIMARY KEY]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement to reference a table with a primary key, or define a primary key with ALTER TABLE ADD PRIMARY KEY before referencing the table in a FOREIGN KEY clause.]]></programmersResponse>
		<sqlState>42888</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-540</code>
		<message><![CDATA[THE DEFINITION OF TABLE table-name IS INCOMPLETE BECAUSE IT LACKS A PRIMARY INDEX OR A REQUIRED UNIQUE INDEX]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Define a primary index or a required unique index on the table before referencing it.]]></programmersResponse>
		<sqlState>57001</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-542</code>
		<message><![CDATA[column-name CANNOT BE A COLUMN OF A PRIMARY KEY, A UNIQUE CONSTRAINT, OR A PARENT KEY BECAUSE IT CAN CONTAIN NULL VALUES]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[In the case of a column identified in a PRIMARY KEY or a UNIQUE constraint clause, correct the statement and rerun it.
In the case of a column identified in a REFERENCES clause, drop the parent table then recreate it with referenced columns defined as NOT NULL. Afterwards, rerun the statement.]]></programmersResponse>
		<sqlState>42831</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-543</code>
		<message><![CDATA[A ROW IN A PARENT TABLE CANNOT BE DELETED BECAUSE THE CHECK CONSTRAINT check-constraint RESTRICTS THE DELETION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine the foreign key and its delete rule in the dependent table and the conflicting check constraint. Change either the delete rule or the check constraint so that they do not conflict.]]></programmersResponse>
		<sqlState>23511</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-544</code>
		<message><![CDATA[THE CHECK CONSTRAINT SPECIFIED IN THE ALTER TABLE STATEMENT CANNOT BE ADDED BECAUSE AN EXISTING ROW VIOLATES THE CHECK CONSTRAINT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine the check constraint definition that was specified in the ALTER TABLE statement and the data in the table to determine why the ALTER TABLE statement was rejected.
You can determine which rows violated the check constraint by using the SELECT statement, negating the check constraint in the WHERE clause. For example:
 - SELECT * FROM table WHERE (NOT (check-condition));]]></programmersResponse>
		<sqlState>23512</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-545</code>
		<message><![CDATA[THE REQUESTED OPERATION IS NOT ALLOWED BECAUSE A ROW DOES NOT SATISFY THE CHECK CONSTRAINT check-constraint]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine the data and the check constraint definition in the SYSIBM.SYSCHECKS catalog table to determine why the INSERT or UPDATE statement was rejected. The data must be changed to satisfy the check constraint.]]></programmersResponse>
		<sqlState>23513</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-546</code>
		<message><![CDATA[THE CHECK CONSTRAINT constraint-name IS INVALID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the check constraint definition and execute the statement again.]]></programmersResponse>
		<sqlState>42621</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-548</code>
		<message><![CDATA[A CHECK CONSTRAINT THAT IS DEFINED WITH column-name IS INVALID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the check constraint definition and execute the statement again.]]></programmersResponse>
		<sqlState>42621</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-549</code>
		<message><![CDATA[THE statement STATEMENT IS NOT ALLOWED FOR object_type1 object_name BECAUSE THE BIND OPTION DYNAMICRULES(RUN) IS NOT IN EFFECT FOR object_type2]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Do one of the following to correct the error:
 - If the SQL statement is embedded, remove it, precompile and compile the application program again, and reissue the BIND command with the desired DYNAMICRULES option.
 - If appropriate, use the SQL statement with a package or plan that is bound with DYNAMICRULES(RUN).
 - Issue the REBIND command with the DYNAMICRULES(RUN) option for the plan or package to which the SQL statement is bound

Refer to the BIND PACKAGE(DSN), BIND PLAN(DSN), REBIND PACKAGE(DSN), or REBIND PLAN(DSN) statement in DB2 Command Reference for the description of the DYNAMICRULES option and the expected results. Determine if either the SQL statement should be removed from the program or the plan or package should be rebound with the DYNAMICRULES(RUN) option.]]></programmersResponse>
		<sqlState>42509</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-551</code>
		<message><![CDATA[auth-id DOES NOT HAVE THE PRIVILEGE TO PERFORM OPERATION operation ON OBJECT object-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure that auth-id was granted the authority to perform the desired operation, the object-name exists, and auth-id is not trying to create a table with a different authorization ID.]]></programmersResponse>
		<sqlState>42501</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-552</code>
		<message><![CDATA[auth-id DOES NOT HAVE THE PRIVILEGE TO PERFORM OPERATION operation]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure that the authorization ID has been granted the authority necessary to perform the desired operation.]]></programmersResponse>
		<sqlState>42502</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-553</code>
		<message><![CDATA[auth-id SPECIFIED IS NOT ONE OF THE VALID AUTHORIZATION IDS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the error in the statement or contact the security administrator to have the authorization ID defined for your use.]]></programmersResponse>
		<sqlState>42503</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-554</code>
		<message><![CDATA[AN AUTHORIZATION ID CANNOT GRANT A PRIVILEGE TO ITSELF]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Refer to Chapter 4 of DB2 SQL Reference for information about restrictions on the use of the GRANT statement.]]></programmersResponse>
		<sqlState>42502</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-555</code>
		<message><![CDATA[AN AUTHORIZATION ID CANNOT REVOKE A PRIVILEGE FROM ITSELF]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Refer to Chapter 5 of DB2 SQL Reference for information about restrictions on the use of the REVOKE statement.]]></programmersResponse>
		<sqlState>42502</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-556</code>
		<message><![CDATA[authid2 CANNOT HAVE THE privilege PRIVILEGE on_object REVOKED BY authid1 BECAUSE THE REVOKEE DOES NOT POSSESS THE PRIVILEGE OR THE REVOKER DID NOT MAKE THE GRANT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Check the appropriate authorization catalog tables to verify that authid2 possesses the privilege to be revoked. Queries can be made with GRANTEE = authid2 and the privilege column not = blanks. Correct and reissue the REVOKE statement.
If a user holding SYSADM or SYSCTRL authority receives this SQLCODE, the BY clause might have been omitted from the REVOKE statement.]]></programmersResponse>
		<sqlState>42504</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-557</code>
		<message><![CDATA[INCONSISTENT GRANT/REVOKE KEYWORD keyword. PERMITTED KEYWORDS ARE keyword-list]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the syntax of the GRANT or REVOKE statement.]]></programmersResponse>
		<sqlState>42852</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-558</code>
		<message><![CDATA[INVALID CLAUSE OR COMBINATION OF CLAUSES ON A GRANT OR REVOKE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Refer to Chapter 5 of DB2 SQL Reference for valid keywords for the GRANT statement.]]></programmersResponse>
		<sqlState>56025</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-559</code>
		<message><![CDATA[ALL AUTHORIZATION FUNCTIONS HAVE BEEN DISABLED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Do not attempt to execute GRANT or REVOKE statements unless and until the authorization mechanism is enabled in the DB2 subsystem.]]></programmersResponse>
		<sqlState>57002</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-567</code>
		<message><![CDATA[bind-type AUTHORIZATION ERROR USING auth-id AUTHORITY PACKAGE = package-name PRIVILEGE = privilege]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The indicated privilege must be granted to the authorization ID that will become the package owner.]]></programmersResponse>
		<sqlState>42501</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-571</code>
		<message><![CDATA[THE STATEMENT WOULD RESULT IN A MULTIPLE SITE UPDATE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure that all requests for modifications to the data are confined to a single location within any given commit scope for any application that references a location that does not support multi-site update.
For programs operating in an IMS or CICS environment where the remote database systems do not support multi-site update, all SQL statements must be read-only access.
If an autobind is causing this SQLCODE to be issued, REBIND the plan or package.]]></programmersResponse>
		<sqlState>25000</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-573</code>
		<message><![CDATA[TABLE table-name DOES NOT HAVE A UNIQUE KEY WITH THE SPECIFIED COLUMN NAMES]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Create a unique index with the specified columns for the parent table.]]></programmersResponse>
		<sqlState>42890</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-574</code>
		<message><![CDATA[THE SPECIFIED DEFAULT VALUE OR IDENTITY ATTRIBUTE VALUE CONFLICTS WITH THE DEFINITION OF COLUMN column-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Specify a default value that is valid for the definition of the column.]]></programmersResponse>
		<sqlState>42894</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-575</code>
		<message><![CDATA[VIEW view-name CANNOT BE REFERENCED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Issue an ALTER VIEW statement to regenerate the view.]]></programmersResponse>
		<sqlState>51024</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-577</code>
		<message><![CDATA[object-type object-name ATTEMPTED TO MODIFY DATA WHEN THE DEFINITION OF THE FUNCTION OR PROCEDURE DID NOT SPECIFY THIS ACTION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Either use an ALTER statement to change the definition of the function or procedure to allow statements that modify data, or remove the failing SQL statement from the external function or procedure.]]></programmersResponse>
		<sqlState>38002</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-579</code>
		<message><![CDATA[object-type object-name ATTEMPTED TO READ DATA WHEN THE DEFINITION OF THE FUNCTION OR PROCEDURE DID NOT SPECIFY THIS ACTION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Either use an ALTER statement to change the definition of the function or procedure to allow statements that read data, or remove the failing SQL statement from the external function or procedure.]]></programmersResponse>
		<sqlState>38004</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-580</code>
		<message><![CDATA[THE RESULT-EXPRESSIONS OF A CASE EXPRESSION CANNOT ALL BE NULL]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the CASE expression to include at least one result-expression with a keyword other than NULL.]]></programmersResponse>
		<sqlState>42625</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-581</code>
		<message><![CDATA[THE DATA TYPES OF THE RESULT-EXPRESSIONS OF A CASE EXPRESSION ARE NOT COMPATIBLE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the result-expressions so that they are compatible.]]></programmersResponse>
		<sqlState>42804</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-582</code>
		<message><![CDATA[THE SEARCH-CONDITION IN A SEARCHED-WHEN-CLAUSE CANNOT BE A QUANTIFIED PREDICATE, IN PREDICATE, OR AN EXISTS PREDICATE.]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the search-condition.]]></programmersResponse>
		<sqlState>42625</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-583</code>
		<message><![CDATA[THE USE OF FUNCTION function-name IS INVALID BECAUSE IT IS NOT DETERMINISTIC OR MAY HAVE AN EXTERNAL ACTION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If the use of a not deterministic or external action function was not intended, substitute a function without these characteristics. If the behavior associated with the not deterministic or external action function is intentional, use the alternate form of the statements that make that intent explicit.

Instead of a simple-when-clause, use the corresponding searched-when-clause where the function would get specified in each search-condition.
Remove the WITH CHECK OPTION from the CREATE VIEW statement.
Remove the function from the ORDER BY clause. If the column is part of the result set of the query, change the expression in the ORDER BY clause to the simple-integer or simple-column-name form of the sort key. See the ORDER BY syntax diagram in the DB2 SQL Reference for more information.]]></programmersResponse>
		<sqlState>42845</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-585</code>
		<message><![CDATA[THE COLLECTION collection-id APPEARS MORE THAN ONCE IN THE SET special-register STATEMENT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Remove duplicate occurrences of collection-id from the SET statement for the special register.]]></programmersResponse>
		<sqlState>42732</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-586</code>
		<message><![CDATA[THE TOTAL LENGTH OF THE CURRENT PATH SPECIAL REGISTER CANNOT EXCEED 2048 CHARACTERS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Remove schema names to reduce the total length to fit the 2048 character maximum length. If all the schema names are required, it may be necessary to consolidate some user-defined functions so that fewer schema names are required for the CURRENT PATH.]]></programmersResponse>
		<sqlState>42907</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-589</code>
		<message><![CDATA[A POSITIONED DELETE OR UPDATE STATEMENT FOR CURSOR cursor-name SPECIFIED A ROW OF A ROWSET, BUT THE CURSOR IS NOT POSITIONED ON A ROWSET]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Issue a FETCH statement to position the cursor on the desired rowset, and then reissue the positioned DELETE or UPDATE statement. If the cursor is not defined for rowset access, redefine the cursor first.]]></programmersResponse>
		<sqlState>24520</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-590</code>
		<message><![CDATA[PARAMETER NAME parameter-name IS NOT UNIQUE IN THE CREATE FOR ROUTINE routine-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the name of the parameter to make all of the parameter names unique within the CREATE statement.]]></programmersResponse>
		<sqlState>42734</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-592</code>
		<message><![CDATA[NOT AUTHORIZED TO CREATE FUNCTIONS OR PROCEDURES IN WLM ENVIRONMENT env-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[To correct the error, perform one of the following actions:
 - If the value of the env-name token is 'NO WLM ENVIRONMENT', choose a different value for the WLM ENVIRONMENT keyword or request authorization to create objects in the specified WLM ENVIRONMENT from the system administrator.
 - If there is no DB2-managed stored procedures address space, request that one be created. Also request that a RACF PERMIT be completed to allow access to this resource.

After doing one of the above, reissue the SQL statement.]]></programmersResponse>
		<sqlState>42510</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-593</code>
		<message><![CDATA[NOT NULL MUST BE SPECIFIED FOR ROWID OR DISTINCT TYPE COLUMN column-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the statement to specify NOT NULL for ROWID column column-name.]]></programmersResponse>
		<sqlState>42831</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-601</code>
		<message><![CDATA[THE NAME OF THE OBJECT TO BE CREATED OR THE TARGET OF A RENAME STATEMENT IS IDENTICAL TO THE EXISTING NAME name OF THE OBJECT TYPE obj-type]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Either drop the existing object or choose another name. If obj-type is data set, do an IDCAMS DELETE of the data set before retrying the CREATE. Refer to Chapter 2 of DB2 SQL Reference for information about the scope of object names in DB2.]]></programmersResponse>
		<sqlState>42710</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-602</code>
		<message><![CDATA[TOO MANY COLUMNS SPECIFIED IN A CREATE INDEX OR ALTER INDEX STATEMENT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The index definition must be modified to conform to the system-imposed column limit of 64.]]></programmersResponse>
		<sqlState>54008</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-603</code>
		<message><![CDATA[A UNIQUE INDEX CANNOT BE CREATED BECAUSE THE TABLE CONTAINS ROWS WHICH ARE DUPLICATES WITH RESPECT TO THE VALUES OF THE IDENTIFIED COLUMNS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine the data to ascertain whether or not the duplicate data is valid. Alternatively, consider creating a nonunique index.]]></programmersResponse>
		<sqlState>23515</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-604</code>
		<message><![CDATA[A DATA TYPE DEFINITION SPECIFIES AN INVALID LENGTH, PRECISION, OR SCALE ATTRIBUTE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the syntax, and resubmit the statement. Refer to Chapter 2 of DB2 SQL Reference for information about valid length, precision, and scale attributes for the data type of an object.]]></programmersResponse>
		<sqlState>42611</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-607</code>
		<message><![CDATA[OPERATION OR OPTION operation IS NOT DEFINED FOR THIS OBJECT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If an option of the SQL statement is not allowed for this object, modify the SQL statement and resubmit the statement. If an operation is not defined for the object, the statement cannot be executed.]]></programmersResponse>
		<sqlState>42832</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-611</code>
		<message><![CDATA[ONLY LOCKMAX 0 CAN BE SPECIFIED WHEN THE LOCK SIZE OF THE TABLESPACE IS TABLESPACE OR TABLE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Do one of the following:
 - Reissue the statement with LOCKMAX 0.
 - Alter the LOCKSIZE of the table space to a value other than TABLESPACE or TABLE.]]></programmersResponse>
		<sqlState>53088</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-612</code>
		<message><![CDATA[column-name IS A DUPLICATE COLUMN NAME]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the CREATE statement to specify unique names for each of the columns of the index, table, view, or the columns in the UPDATE OF clause of a trigger definition. Correct the ALTER statement to specify unique names for each of the ALTER COLUMN clauses.
This error can also occur on CREATE TABLE when a column list of a PRIMARY KEY, FOREIGN KEY, or UNIQUE clause contains two or more occurrences of the same column name.]]></programmersResponse>
		<sqlState>42711</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-613</code>
		<message><![CDATA[THE PRIMARY KEY OR A UNIQUE CONSTRAINT IS TOO LONG OR HAS TOO MANY COLUMNS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the table definition to keep within the prescribed limits.]]></programmersResponse>
		<sqlState>54008</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-614</code>
		<message><![CDATA[THE INDEX CANNOT BE CREATED OR ALTERED, OR THE LENGTH OF A COLUMN CANNOT BE CHANGED BECAUSE THE SUM OF THE INTERNAL LENGTHS OF THE COLUMNS FOR THE INDEX IS GREATER THAN THE ALLOWABLE MAXIMUM]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The definition for the index must be modified (possibly by eliminating one or more key columns) to reduce the length of the key to the permitted maximum. Refer to Chapter 5 of DB2 SQL Reference if you require a complete explanation of other possible maximum key lengths and how they are computed.]]></programmersResponse>
		<sqlState>54008</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-615</code>
		<message><![CDATA[operation-type IS NOT ALLOWED ON A PACKAGE IN USE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the application to invoke the BIND, REBIND or DROP operation when the package is not use by the same application process.]]></programmersResponse>
		<sqlState>55006</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-616</code>
		<message><![CDATA[obj-type1 obj-name1 CANNOT BE DROPPED BECAUSE IT IS REFERENCED BY obj-type2 obj-name2]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify that the object specified in the DROP statement was, indeed, the object to be dropped. If so, all the existing objects that have a dependency on that object must first be dropped.
A LOB table space cannot be dropped when an association exists between it and another table space. The associated base table must be dropped first.
A populated auxiliary table and its index can only be dropped by dropping the associated base table.
A trigger package cannot be explicitly dropped. It can only be dropped by dropping the associated trigger with a DROP TRIGGER statement or by dropping the triggering table.]]></programmersResponse>
		<sqlState>42893</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-618</code>
		<message><![CDATA[OPERATION operation IS NOT ALLOWED ON SYSTEM DATABASES]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Do not attempt to perform the requested operation on system databases.]]></programmersResponse>
		<sqlState>42832</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-619</code>
		<message><![CDATA[OPERATION DISALLOWED BECAUSE THE DATABASE IS NOT STOPPED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Issue the -DISPLAY DATABASE command to verify that the work file database is stopped before resubmitting the statement.]]></programmersResponse>
		<sqlState>55011</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-620</code>
		<message><![CDATA[KEYWORD keyword IN stmt type STATEMENT IS NOT PERMITTED FOR A space type SPACE IN THE database type DATABASE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Refer to DB2 SQL Reference for information about attributes that are allowed or not allowed for a space type space in a database type database. Correct and resubmit the stmt type statement.]]></programmersResponse>
		<sqlState>53001</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-621</code>
		<message><![CDATA[DUPLICATE DBID dbid WAS DETECTED AND PREVIOUSLY ASSIGNED TO database-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Notify the system programmer. The inconsistency must be corrected before CREATE DATABASE will be successful.
System Programmer Response: If you suspect an error in DB2, refer to Part 2 of DB2 Diagnosis Guide and Reference for information on identifying and reporting the problem.]]></programmersResponse>
		<sqlState>58001</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-622</code>
		<message><![CDATA[FOR MIXED DATA IS INVALID BECAUSE THE MIXED DATA INSTALL OPTION IS NO]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Either change the install option or the FOR clause. If the install option is correctly set to NO, the allowable FOR clause options are BIT and SBCS.]]></programmersResponse>
		<sqlState>56031</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-623</code>
		<message><![CDATA[A CLUSTERING INDEX ALREADY EXISTS ON TABLE table-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Check to determine the identity and validity of the existing cluster index on the object table. Alternatively, consider creating the index without the CLUSTER attribute.]]></programmersResponse>
		<sqlState>55012</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-624</code>
		<message><![CDATA[TABLE table-name ALREADY HAS A PRIMARY KEY OR UNIQUE KEY CONSTRAINT WITH SPECIFIED COLUMNS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Do not attempt to define a table with more than one primary key, or a unique constraint that duplicates the definition of an existing unique constraint.]]></programmersResponse>
		<sqlState>42889</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-625</code>
		<message><![CDATA[TABLE table-name DOES NOT HAVE AN INDEX TO ENFORCE THE UNIQUENESS OF THE PRIMARY OR UNIQUE KEY]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Make sure the key list specified on the ALTER TABLE statement identifies an existing unique index of the table that is not already enforcing referential constraints.]]></programmersResponse>
		<sqlState>55014</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-626</code>
		<message><![CDATA[THE ALTER STATEMENT IS NOT EXECUTABLE BECAUSE THE PAGE SET IS NOT STOPPED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Stop the page set before resubmitting the statement.]]></programmersResponse>
		<sqlState>55015</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-627</code>
		<message><![CDATA[THE ALTER STATEMENT IS INVALID BECAUSE THE PAGESET HAS USER-MANAGED DATA SETS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify that the correct table or partition is specified. The primary and secondary space allocation of a user-managed data set cannot be altered by means of an ALTER statement.]]></programmersResponse>
		<sqlState>55016</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-628</code>
		<message><![CDATA[THE CLAUSES ARE MUTUALLY EXCLUSIVE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the options specified in the statement, and reissue the statement.]]></programmersResponse>
		<sqlState>42613</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-629</code>
		<message><![CDATA[SET NULL CANNOT BE SPECIFIED BECAUSE FOREIGN KEY name CANNOT CONTAIN NULL VALUES]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change a column of the key to allow null values or change the delete rule.]]></programmersResponse>
		<sqlState>42834</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-631</code>
		<message><![CDATA[FOREIGN KEY name IS TOO LONG OR HAS TOO MANY COLUMNS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The table definition must be modified to conform to the system-imposed limit of the sum of the length attributes of the columns identified in the PRIMARY KEY clause.]]></programmersResponse>
		<sqlState>54008</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-632</code>
		<message><![CDATA[THE TABLE CANNOT BE DEFINED AS A DEPENDENT OF table-name BECAUSE OF DELETE RULE RESTRICTIONS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Eliminate the particular FOREIGN KEY clause from the ALTER or CREATE TABLE statement.]]></programmersResponse>
		<sqlState>42915</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-633</code>
		<message><![CDATA[THE DELETE RULE MUST BE delete-rule]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the 'delete rule' in the FOREIGN KEY clause.]]></programmersResponse>
		<sqlState>42915</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-634</code>
		<message><![CDATA[THE DELETE RULE MUST NOT BE CASCADE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the delete rule.]]></programmersResponse>
		<sqlState>42915</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-635</code>
		<message><![CDATA[THE DELETE RULES CANNOT BE DIFFERENT OR CANNOT BE SET NULL]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the delete rule.]]></programmersResponse>
		<sqlState>42915</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-636</code>
		<message><![CDATA[THE PARTITIONING KEYS FOR PARTITION part-num ARE NOT SPECIFIED IN ASCENDING OR DESCENDING ORDER]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the limit key value specifications in the CREATE INDEX or ALTER INDEX statement for the identified partitionso that the limit key values for successive partitions are in strictly ascending or descending order.]]></programmersResponse>
		<sqlState>56016</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-637</code>
		<message><![CDATA[DUPLICATE keyword KEYWORD]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement by removing duplicate clauses.]]></programmersResponse>
		<sqlState>42614</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-638</code>
		<message><![CDATA[TABLE table-name CANNOT BE CREATED BECAUSE COLUMN DEFINITION IS MISSING]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Add column definition to the statement.]]></programmersResponse>
		<sqlState>42601</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-639</code>
		<message><![CDATA[A NULLABLE COLUMN OF A FOREIGN KEY WITH A DELETE RULE OF SET NULL CANNOT BE A COLUMN OF THE KEY OF A PARTITIONED INDEX]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Review the delete rule of the referential constraint and the partition keys for the index. Do one of the following:
 - If the operation in error was CREATE INDEX, either change the index partition key definition or drop and redefine the referential constraint with a different delete rule.
 - If the operation in error was ALTER TABLE, change the referential delete rule so that all nullable index keys are not part of the foreign keys.]]></programmersResponse>
		<sqlState>56027</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-640</code>
		<message><![CDATA[LOCKSIZE ROW CANNOT BE SPECIFIED BECAUSE TABLE IN THIS TABLESPACE HAS TYPE 1 INDEX]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Since the LOCKSIZE ROW on the table space and the type 1 indexes conflict, either use the ALTER INDEX statement to convert all type 1 indexes to type 2 indexes or use another LOCKSIZE option.]]></programmersResponse>
		<sqlState>56089</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-643</code>
		<message><![CDATA[CHECK CONSTRAINT EXCEEDS MAXIMUM ALLOWABLE LENGTH]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Rewrite the check constraint definition so that it is less than 3800 characters. You might need to divide the check constraint into two or more smaller check constraints.]]></programmersResponse>
		<sqlState>54024</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-644</code>
		<message><![CDATA[INVALID VALUE SPECIFIED FOR KEYWORD OR CLAUSE keyword-or-clause IN STATEMENT stmt-type]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement. Refer to Chapter 5 of DB2 SQL Reference for information about the permissible values for the keyword-or-clause keyword in stmt-type statements.]]></programmersResponse>
		<sqlState>42615</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-646</code>
		<message><![CDATA[TABLE table-name CANNOT BE CREATED IN SPECIFIED TABLE SPACE table-space-name BECAUSE IT ALREADY CONTAINS A TABLE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify that the correct table space was specified in the CREATE statement. Do not attempt to create more than one table in a partitioned, implicitly defined, or LOB table space.]]></programmersResponse>
		<sqlState>55017</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-647</code>
		<message><![CDATA[BUFFERPOOL bp-name CANNOT BE SPECIFIED BECAUSE IT HAS NOT BEEN ACTIVATED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify that the proper buffer pool was specified in the CREATE or ALTER statement. Use the -DISPLAY BUFFERPOOL command to display the attributes of the buffer pool and determine if the buffer pool is activated. If the buffer pool is not activated, use the -ALTER BUFFERPOOL command to change the VPSIZE from 0 to the desired size.]]></programmersResponse>
		<sqlState>57003</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-650</code>
		<message><![CDATA[THE ALTER STATEMENT CANNOT BE EXECUTED, REASON reason]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the error according to the given reason and reissue the statement.]]></programmersResponse>
		<sqlState>56090</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-651</code>
		<message><![CDATA[TABLE DESCRIPTION EXCEEDS MAXIMUM SIZE OF OBJECT DESCRIPTOR.]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the statement by reducing either the number or length (or a combination of both) of the user-defined default string constants or check constraints and execute the statement again.
System Action: The statement is not executed. For an ALTER TABLE statement, the definition of the table is unchanged. For a CREATE TABLE statement, the table is not created.]]></programmersResponse>
		<sqlState>54025</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-652</code>
		<message><![CDATA[VIOLATION OF INSTALLATION DEFINED EDIT OR VALIDATION PROCEDURE proc-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Determine the requirements imposed by the edit or validation procedure for inserts and updates of the object table.]]></programmersResponse>
		<sqlState>23506</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-653</code>
		<message><![CDATA[TABLE table-name IN PARTITIONED TABLE SPACE tspace-name IS NOT AVAILABLE BECAUSE ITS PARTITIONED INDEX HAS NOT BEEN CREATED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify that the correct table was specified in the statement. If so, ensure that the partitioned index for the table has been created successfully before attempting to execute any SQL manipulative statements that reference that table.]]></programmersResponse>
		<sqlState>57004</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-655</code>
		<message><![CDATA[THE CREATE OR ALTER STOGROUP IS INVALID BECAUSE THE STORAGE GROUP WOULD HAVE BOTH SPECIFIC AND NON-SPECIFIC VOLUME IDS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Specify either specific or non-specific volume IDs in the VOLUMES clause of CREATE STOGROUP statement and the ADD VOLUMES clause of the ALTER STOGROUP statement. To add specific volume IDs to a storage group with non-specific volume IDs, use the REMOVE VOLUMES clause to remove the non-specific volume IDs. To add non-specific volume IDs to a storage group with specific volume IDs, use the REMOVE VOLUMES clause to remove the specific volume IDs.]]></programmersResponse>
		<sqlState>56036</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-658</code>
		<message><![CDATA[A object-type CANNOT BE DROPPED USING THE statement STATEMENT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Issue the appropriate DROP statement to drop the intended objects.]]></programmersResponse>
		<sqlState>42917</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-660</code>
		<message><![CDATA[INDEX index-name CANNOT BE CREATED OR ALTERED ON PARTITIONED TABLE SPACE tspace-name BECAUSE KEY LIMITS ARE NOT SPECIFIED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify that the correct table was specified in the CREATE INDEX or ALTER INDEX statement. If so, the definition for the partitioned table space must be examined so that a proper definition for the cluster index for the table may be constructed. Refer to Chapter 5 of DB2 SQL Reference for information about the requirements that must be satisfied by the definitions for the cluster indexes for partitioned tables.]]></programmersResponse>
		<sqlState>53035</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-661</code>
		<message><![CDATA[object-type index-name CANNOT BE CREATED ON PARTITIONED TABLE SPACE tspace-name BECAUSE THE NUMBER OF PART SPECIFICATIONS IS NOT EQUAL TO THE NUMBER OF PARTITIONS OF THE TABLE SPACE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine the definition of the partitioned table space to determine how many partitions have been specified, and then correct the syntax of the CREATE INDEX statement to provide the proper number of PART specifications. Refer to Chapter 5 of DB2 SQL Reference for information about the definitions for cluster indexes on partitioned tables.]]></programmersResponse>
		<sqlState>53036</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-662</code>
		<message><![CDATA[A PARTITIONED INDEX CANNOT BE CREATED ON A NON-PARTITIONED TABLE SPACE tspace-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify that the proper object table was specified in the statement. Refer to Chapter 5 of DB2 SQL Reference for information about the proper usage of PART specifications in CREATE INDEX statements.]]></programmersResponse>
		<sqlState>53037</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-663</code>
		<message><![CDATA[THE NUMBER OF KEY LIMIT VALUES IS EITHER ZERO, OR GREATER THAN THE NUMBER OF COLUMNS IN THE KEY OF INDEX index-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement so that each PART specification contains exactly the same number of limit key value specifications as there are columns in the index key.]]></programmersResponse>
		<sqlState>53038</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-665</code>
		<message><![CDATA[THE PART CLAUSE OF AN ALTER STATEMENT IS OMITTED OR INVALID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Determine whether the table space or index you want to alter is partitioned. If it is partitioned, specify a PART clause that identifies the partition you want to alter. If it is not partitioned, do not specify the PART clause.]]></programmersResponse>
		<sqlState>53039</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-666</code>
		<message><![CDATA[stmt-verb object CANNOT BE EXECUTED BECAUSE function IS IN PROGRESS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If the function is a utility, wait for the function to complete or stop. Then resubmit the statement for execution.
If the function is the governor, the statement cannot be executed until the resource limit facility is stopped or switched to a different resource limit specification table (RLST). In a DB2 data sharing environment, the resource limit facility must be stopped on all members of the DB2 data sharing group or all members must switch to an RLST that is not associated with the object.
If the function is the DDF, the facility must be stopped before the object can be dropped. In a DB2 data sharing environment, the facility must be stopped on all members of the DB2 data sharing group.]]></programmersResponse>
		<sqlState>57005</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-667</code>
		<message><![CDATA[THE CLUSTERING INDEX FOR A PARTITIONED TABLE SPACE CANNOT BE EXPLICITLY DROPPED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The cluster index for a table in a partitioned table space can only be dropped implicitly when the associated partitioned table space is dropped.]]></programmersResponse>
		<sqlState>42917</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-668</code>
		<message><![CDATA[THE COLUMN CANNOT BE ADDED TO THE TABLE BECAUSE THE TABLE HAS AN EDIT PROCEDURE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify that the correct table was specified in the ALTER statement. Do not attempt to ALTER the definition of a table that has an installation-written edit procedure associated with it.]]></programmersResponse>
		<sqlState>56018</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-669</code>
		<message><![CDATA[THE OBJECT CANNOT BE EXPLICITLY DROPPED. REASON reason-code]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If the statement is a DROP TABLE statement, the table of a partitioned table space can only be dropped implicitly when the table space itself is dropped.
If the statement is a DROP INDEX statement and you do not want to keep the primary key, unique key, or referential constraint, use the DROP CONSTRAINT clause of the ALTER TABLE statement to remove the constraint, then drop the index.]]></programmersResponse>
		<sqlState>42917</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-670</code>
		<message><![CDATA[THE RECORD LENGTH OF THE TABLE EXCEEDS THE PAGE SIZE LIMIT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[In the case of CREATE TABLE, either (1) the row length of the table must be reduced (by eliminating or reducing the lengths of one or more of the columns), or (2) the table must be assigned to a table space that uses a larger buffer pool (assuming that the row length of the table does not exceed that page size limit).
In the case of ALTER TABLE, either (1) the length of the column to be added to the table must be reduced or, (2) if the row length of the table is already at the maximum, the table cannot be altered to add any additional columns.
In the case of a row length that exceeds the page size of a work file table space, eliminate columns from the result of the join.
In the case of a large sort record in which the row length exceeds the page size of a work file table space, eliminate columns from the SELECT list or reduce the number of columns that are being sorted.]]></programmersResponse>
		<sqlState>54010</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-671</code>
		<message><![CDATA[THE BUFFERPOOL ATTRIBUTE OF THE TABLE SPACE CANNOT BE ALTERED AS SPECIFIED BECAUSE IT WOULD CHANGE THE PAGE SIZE OF THE TABLE SPACE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[For example, if the table space uses one of the 4KB buffer pools (for example, BP0, BP1, or BP2), it can be reassigned to one of the other 4KB buffer pools (but not buffer pool BP32K). If, however, it is assigned to buffer pool BP32K, the buffer pool assignment cannot be subsequently altered.]]></programmersResponse>
		<sqlState>53040</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-672</code>
		<message><![CDATA[OPERATION DROP NOT ALLOWED ON TABLE table_name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Before dropping the table, alter the table, specifying DROP RESTRICT ON DROP.
For DROP TABLESPACE or DROP DATABASE, make sure that there are no other tables within the table space or database with the RESTRICT ON DROP attribute. The following SELECT statement can identify the tables:
 - SELECT CREATOR, NAME FROM SYSIBM.SYSTABLES WHERE TYPE = 'T' AND CLUSTERTYPE = 'Y' AND DBNAME = 'database_name' AND TSNAME = 'tablespace_name';]]></programmersResponse>
		<sqlState>55035</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-676</code>
		<message><![CDATA[ONLY A 4K PAGE BUFFERPOOL CAN BE USED FOR AN INDEX]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement to specify a 4KB buffer pool. Refer to Chapter 5 of DB2 SQL Reference for information about the syntax of SQL statements.]]></programmersResponse>
		<sqlState>53041</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-677</code>
		<message><![CDATA[INSUFFICIENT VIRTUAL STORAGE FOR BUFFERPOOL EXPANSION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If this error should occur during interactive execution of an SQL statement or execution of an application program, installation administration should be notified.
Installation Action: It may be necessary to reexamine the buffer pool storage strategy.
One of the following messages has also been sent to the MVS console: DSNB601I, DSNB603I, or DSNB605I. Refer to &quot;DB2 messages&quot; in topic 3.0 for explanations of these messages.]]></programmersResponse>
		<sqlState>57011</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-678</code>
		<message><![CDATA[THE LITERAL literal SPECIFIED FOR THE INDEX LIMIT KEY MUST CONFORM TO THE DATA TYPE data-type OF THE CORRESPONDING COLUMN column-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement so that each limit key value literal is of precisely the same data type as that of the corresponding index key column.]]></programmersResponse>
		<sqlState>53045</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-679</code>
		<message><![CDATA[THE OBJECT name CANNOT BE CREATED BECAUSE A DROP IS PENDING ON THE OBJECT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The logic of the application program must be modified to issue a COMMIT (or the IMS or CICS equivalent) between the DROP and CREATE statements.]]></programmersResponse>
		<sqlState>57006</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-680</code>
		<message><![CDATA[TOO MANY COLUMNS SPECIFIED FOR A TABLE, VIEW OR TABLE FUNCTION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the CREATE statement to not include more than 750 columns, or do not try to alter an existing table to contain more than 750 columns.]]></programmersResponse>
		<sqlState>54011</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-681</code>
		<message><![CDATA[COLUMN column-name IN VIOLATION OF INSTALLATION DEFINED FIELD PROCEDURE. RT: return-code, RS: reason-code, MSG: message-token]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If it is not a field procedure error, determine the requirements imposed by the field procedure. If it is a field procedure error, examine the field procedure.]]></programmersResponse>
		<sqlState>23507</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-682</code>
		<message><![CDATA[FIELD PROCEDURE procedure-name COULD NOT BE LOADED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The application should either commit or roll back to previous COMMIT. Then, in general, the application should terminate.]]></programmersResponse>
		<sqlState>57010</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-683</code>
		<message><![CDATA[THE SPECIFICATION FOR COLUMN, DISTINCT TYPE, FUNCTION, OR PROCEDURE data-item CONTAINS INCOMPATIBLE CLAUSES]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the SQL statement by removing the incompatible specification.]]></programmersResponse>
		<sqlState>42842</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-684</code>
		<message><![CDATA[THE LENGTH OF LITERAL LIST BEGINNING string IS TOO LONG]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the SQL statement.]]></programmersResponse>
		<sqlState>54012</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-685</code>
		<message><![CDATA[INVALID FIELD TYPE, column-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the field procedure so that it returns a valid data type code.]]></programmersResponse>
		<sqlState>58002</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-686</code>
		<message><![CDATA[COLUMN DEFINED WITH A FIELD PROCEDURE CAN NOT COMPARE WITH ANOTHER COLUMN WITH DIFFERENT FIELD PROCEDURE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the SQL statement. Refer to Chapter 2 of DB2 SQL Reference for comparison restrictions between columns defined with a field procedure.]]></programmersResponse>
		<sqlState>53043</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-687</code>
		<message><![CDATA[FIELD TYPES INCOMPARABLE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the SQL statement. Refer to Chapter 2 of DB2 SQL Reference for comparison restrictions between columns defined with a field procedure.]]></programmersResponse>
		<sqlState>53044</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-688</code>
		<message><![CDATA[INCORRECT DATA RETURNED FROM FIELD PROCEDURE, column-name, msgno]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the field procedure so that it returns values that are consistent with their descriptions.]]></programmersResponse>
		<sqlState>58002</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-689</code>
		<message><![CDATA[TOO MANY COLUMNS DEFINED FOR A DEPENDENT TABLE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the SQL statement to conform to the column limit for a dependent table.]]></programmersResponse>
		<sqlState>54011</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-690</code>
		<message><![CDATA[THE STATEMENT IS REJECTED BY DATA DEFINITION CONTROL SUPPORT. REASON reason-code]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[None if valid rejection. Otherwise, check to see if data definition control support is running under the desired mode. Check one or both registration table(s) to determine if the entries of the registration table(s) are correct. If they are not, then update the registration table(s).]]></programmersResponse>
		<sqlState>23508</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-691</code>
		<message><![CDATA[THE REQUIRED REGISTRATION TABLE table-name DOES NOT EXIST]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Determine whether the required registration tables do exist. If not, create the required tables.]]></programmersResponse>
		<sqlState>57018</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-692</code>
		<message><![CDATA[THE REQUIRED UNIQUE INDEX index-name FOR DDL REGISTRATION TABLE table-name DOES NOT EXIST]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Determine whether the required unique index does exist. If not, create the required index. If the index does exist, but is not unique, drop it and recreate it as a unique index.]]></programmersResponse>
		<sqlState>57018</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-693</code>
		<message><![CDATA[THE COLUMN column-name IN DDL REGISTRATION TABLE OR INDEX table-name (index-name) IS NOT DEFINED PROPERLY]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct or alter the definition of the required registration table or index.]]></programmersResponse>
		<sqlState>55003</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-694</code>
		<message><![CDATA[THE SCHEMA STATEMENT CANNOT BE EXECUTED BECAUSE A DROP IS PENDING ON THE DDL REGISTRATION TABLE table-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Resubmit the job. If the same error happens, check for the application that issued the DROP statement for the application registration table or the object registration table. Either commit the DROP statement which dropped the table and create a new application registration table or object registration table, or issue a ROLLBACK for the DROP statement to put the tables back.]]></programmersResponse>
		<sqlState>57023</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-695</code>
		<message><![CDATA[INVALID VALUE seclabel SPECIFIED FOR SECURITY LABEL COLUMN OF TABLE table-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure that the value that is specified for the security label column is a valid security label. Alternatively, insert the row that specifies DEFAULT for the security label column, or remove the security label column from the insert column list.]]></programmersResponse>
		<sqlState>23523</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-696</code>
		<message><![CDATA[THE DEFINITION OF TRIGGER trigger-name INCLUDES AN INVALID USE OF CORRELATION NAME OR TRANSITION TABLE NAME name. REASON CODE=reason-code]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Remove the invalid correlation name or transition table name along with the preceding keyword.]]></programmersResponse>
		<sqlState>42898</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-697</code>
		<message><![CDATA[OLD OR NEW CORRELATION NAMES ARE NOT ALLOWED IN A TRIGGER DEFINED WITH THE FOR EACH STATEMENT CLAUSE. OLD_TABLE OR NEW_TABLE NAMES ARE NOT ALLOWED IN A TRIGGER WITH THE BEFORE CLAUSE.]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Remove invalid correlation names or change the trigger granularity to FOR EACH ROW.]]></programmersResponse>
		<sqlState>42899</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-713</code>
		<message><![CDATA[THE REPLACEMENT VALUE value FOR special-register IS INVALID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the replacement value. See DB2 SQL Reference for an explanation of the valid values of each special register.]]></programmersResponse>
		<sqlState>42815</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-715</code>
		<message><![CDATA[PROGRAM program-name WITH MARK release-dependency-mark FAILED BECAUSE IT DEPENDS ON FUNCTIONS OF THE RELEASE FROM WHICH FALLBACK HAS OCCURRED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The program cannot be used until the DB2 subsystem is remigrated to the newer release.
Operator Response: Notify the system programmer.
System Programmer Response: Warn users not to use plans or packages containing this program until the DB2 subsystem has been remigrated to the newer release.]]></programmersResponse>
		<sqlState>56064</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-716</code>
		<message><![CDATA[PROGRAM program-name PRECOMPILED WITH INCORRECT LEVEL FOR THIS RELEASE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Precompile the named program again using the current precompiler. Reissue the BIND subcommand.
Problem Determination: If the program was precompiled at an appropriate release, and the problem persists, collect the following:
 - A hexadecimal print of the first record of the failing DBRM The listing from the precompile job that generated the DBRM Output from the BIND attempt.]]></programmersResponse>
		<sqlState>56065</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-717</code>
		<message><![CDATA[bind-type FOR object-type object-name WITH MARK release-dependency-mark FAILED BECAUSE object-type DEPENDS ON FUNCTIONS OF THE RELEASE FROM WHICH FALLBACK HAS OCCURRED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The plan or package cannot be used until the DB2 subsystem is remigrated to the newer release.
Operator Response: Notify the system programmer.
System Programmer Response: Warn users not to use the plan or package until the DB2 subsystem has been remigrated to the newer release.]]></programmersResponse>
		<sqlState>56066</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-718</code>
		<message><![CDATA[REBIND OF PACKAGE package-name FAILED BECAUSE IBMREQD OF ibmreqd IS INVALID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[You must do a BIND ACTION(REPLACE) for this package.]]></programmersResponse>
		<sqlState>56067</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-719</code>
		<message><![CDATA[BIND ADD ERROR USING auth-id AUTHORITY PACKAGE package-name ALREADY EXISTS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Check the SYSIBM.SYSPACKAGE catalog table for names of existing application packages. Re-invoke the BIND subcommand with a 'location.collection.package.version' that is not in use.]]></programmersResponse>
		<sqlState>42710</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-720</code>
		<message><![CDATA[BIND ERROR, ATTEMPTING TO REPLACE PACKAGE = package_name WITH VERSION = version2 BUT THIS VERSION ALREADY EXISTS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[There are two approaches to solve this problem. The first is to precompile the program again with a new version name and reissue the original BIND subcommand. The other approach is not to do the precompile but reissue the BIND subcommand with REPLVER(SAME).]]></programmersResponse>
		<sqlState>42710</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-721</code>
		<message><![CDATA[BIND ERROR FOR PACKAGE = pkg-id CONTOKEN = contoken'X IS NOT UNIQUE SO IT CANNOT BE CREATED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Check the SYSIBM.SYSPACKAGE catalog table for names of existing application packages with the indicated consistency token. Reissue the BIND subcommand such that the location.collection.package.consistency-token is unique within the catalog. The following SQL statement can be used to query the catalog:
 - SELECT COLLID,NAME FROM loc-id.SYSIBM.SYSPACKAGE WHERE HEX(CONTOKEN) = contoken]]></programmersResponse>
		<sqlState>42710</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-722</code>
		<message><![CDATA[bind-type ERROR USING auth-id AUTHORITY PACKAGE package-name DOES NOT EXIST]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Check the SYSPACKAGE catalog table for the correct 'location.collection.package.version' to use.]]></programmersResponse>
		<sqlState>42704</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-723</code>
		<message><![CDATA[AN ERROR OCCURRED IN A TRIGGERED SQL STATEMENT IN trigger-name. INFORMATION RETURNED: SQLCODE: sqlerror, SQLSTATE: sqlstate, MESSAGE TOKENS token-list, SECTION NUMBER section-number]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Contact your Database Administrator to determine why the trigger named in the message received the error.
System Programmer Response: Use the trigger name and section number to determine the failing SQL statement. If the trigger definition is available, use the section number to determine the failing statement. Alternatively, the failing statement can be retrieved from the SYSIBM.SYSPACKSTMT catalog table: SELECT TEXT, SEQNO FROM SYSIBM.SYSPACKSTMT WHERE COLLID = 'schema-name' AND NAME = 'trigger-name' AND SECTNO = section-number ORDER BY SEQNO Refer to the explanation of the reported SQLCODE. Follow the action suggested by that SQLCODE.]]></programmersResponse>
		<sqlState>09000</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-724</code>
		<message><![CDATA[THE ACTIVATION OF THE object-type OBJECT object-name WOULD EXCEED THE MAXIMUM LEVEL OF INDIRECT SQL CASCADING]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Start with the indirect SQL that is activated by the original SQL operation. Check for recursive patterns in any invoked user-defined functions or in any triggers defined on the subject of an update operation. If the chain is not recursive, the cascade chain must be simplified by altering the triggers, user-defined functions, or stored procedures involved.]]></programmersResponse>
		<sqlState>54038</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-725</code>
		<message><![CDATA[THE SPECIAL REGISTER register AT LOCATION location WAS SUPPLIED AN INVALID VALUE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The SET statement should be reissued with a valid value. This situation can be corrected with a local SET statement or with a DRDA SET statement executed at the remote site. Once the special register has been supplied a valid value, the application can resume execution.]]></programmersResponse>
		<sqlState>42721</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-726</code>
		<message><![CDATA[BIND ERROR ATTEMPTING TO REPLACE PACKAGE = package-name. THERE ARE ENABLE OR DISABLE ENTRIES CURRENTLY ASSOCIATED WITH THE PACKAGE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[FREE the package first and then BIND the package.]]></programmersResponse>
		<sqlState>55030</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-728</code>
		<message><![CDATA[DATA TYPE data-type IS NOT ALLOWED IN DB2 PRIVATE PROTOCOL PROCESSING]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If this is an invalid data type, correct the statement. If this is a valid (but disallowed) data type, you can:
 - Remove access to the data type listed, and re-execute the statement.
 - Change the application program so that DRDA is used to access the data.
 - BIND the package containing the statement to the remote site with bind option DBPROTOCOL(DRDA) and rerun the program.

Refer to the DB2 SQL Reference for more information.]]></programmersResponse>
		<sqlState>56080</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-729</code>
		<message><![CDATA[A STORED PROCEDURE SPECIFYING COMMIT ON RETURN CANNOT BE THE TARGET OF A NESTED CALL STATEMENT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Remove the CALL to the stored procedure that was defined with the COMMIT ON RETURN attribute.]]></programmersResponse>
		<sqlState>429B1</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-730</code>
		<message><![CDATA[THE PARENT OF A TABLE IN A READ-ONLY SHARED DATABASE MUST ALSO BE A TABLE IN A READ-ONLY SHARED DATABASE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Insure that the correct tables are being used for the relationship being defined.]]></programmersResponse>
		<sqlState>56053</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-731</code>
		<message><![CDATA[USER-DEFINED DATASET dsname MUST BE DEFINED WITH SHAREOPTIONS(1,3)]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Insure that the data sets used in the shared database are defined with the proper SHAREOPTIONS.]]></programmersResponse>
		<sqlState>56054</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-732</code>
		<message><![CDATA[THE DATABASE IS DEFINED ON THIS SUBSYSTEM WITH THE ROSHARE READ ATTRIBUTE BUT THE TABLE SPACE OR INDEX SPACE HAS NOT BEEN DEFINED ON THE OWNING SUBSYSTEM]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify that the table space or index has been defined on the owning system in a ROSHARE OWNER database.]]></programmersResponse>
		<sqlState>56055</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-733</code>
		<message><![CDATA[THE DESCRIPTION OF A TABLE SPACE, INDEX SPACE, OR TABLE IN A ROSHARE READ DATABASE MUST BE CONSISTENT WITH ITS DESCRIPTION IN THE OWNER SYSTEM]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure that the definition of the table space, index, or table is consistent with that in the ROSHARE OWNER database.]]></programmersResponse>
		<sqlState>56056</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-734</code>
		<message><![CDATA[THE ROSHARE ATTRIBUTE OF A DATABASE CANNOT BE ALTERED FROM ROSHARE READ]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify that the correct database was specified on the ALTER DATABASE statement. The ROSHARE attribute of a read-only shared database cannot be altered. To change this, DROP and recreate the database.]]></programmersResponse>
		<sqlState>56057</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-735</code>
		<message><![CDATA[DATABASE dbid CANNOT BE ACCESSED BECAUSE IT IS NO LONGER A SHARED DATABASE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify that the correct object is specified on the statement.]]></programmersResponse>
		<sqlState>55004</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-736</code>
		<message><![CDATA[INVALID OBID obid SPECIFIED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify that the given OBID is a valid value for an OBID. If so, ensure that the OBID is correct for the object to be created, then query the catalog to find the object that is already defined as having the same OBID in the database. If an invalid OBID was given for the object to be created, correct the statement and execute it again. If the existing object is in error, then DROP and CREATE that object using the correct OBID value.
It is possible that the OBID &quot;in use&quot; is the OBID for an object that had been previously dropped. If that is the case, and the CREATE was issued for a table in a non-ROSHARE READ database, then select a different OBID for use in the OBID clause. If the object had been previously dropped and the CREATE was issued for a table in a ROSHARE READ database, COMMIT and re-submit the CREATE TABLE request.]]></programmersResponse>
		<sqlState>53014</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-737</code>
		<message><![CDATA[IMPLICIT TABLE SPACE NOT ALLOWED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[CREATE a table space for the table, using the same name as is given on the owning system. Then resubmit the CREATE TABLE statement.]]></programmersResponse>
		<sqlState>56056</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-739</code>
		<message><![CDATA[CREATE OR ALTER FUNCTION function-name FAILED BECAUSE FUNCTIONS CANNOT MODIFY DATA WHEN THEY ARE PROCESSED IN PARALLEL.]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Specify DISALLOW PARALLEL or change the MODIFIES SQL DATA to NO SQL, CONTAINS SQL or READS SQL DATA.]]></programmersResponse>
		<sqlState>56088</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-740</code>
		<message><![CDATA[FUNCTION name IS DEFINED WITH THE OPTION MODIFIES SQL DATA WHICH IS NOT VALID IN THE CONTEXT IN WHICH IT WAS INVOKED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Remove the user-defined function from the failing statement. or remove the MODIFIES SQL DATA option from the definition of the function.]]></programmersResponse>
		<sqlState>51034</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-741</code>
		<message><![CDATA[A database-type DATABASE IS ALREADY DEFINED FOR MEMBER member-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify the identity and validity of the existing database-type database for the named DB2 subsystem or data sharing member. The existing database can be altered or dropped if necessary. If the existing database is dropped, resubmit the CREATE DATABASE statement.]]></programmersResponse>
		<sqlState>55020</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-742</code>
		<message><![CDATA[DSNDB07 IS THE IMPLICIT WORK FILE DATABASE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[To create the work file database for a DB2 subsystem that is not a member of a DB2 data sharing group, create database DSNDB07 without the WORKFILE clause.]]></programmersResponse>
		<sqlState>53004</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-746</code>
		<message><![CDATA[THE SQL STATEMENT IN AN EXTERNAL FUNCTION, TRIGGER, OR IN STORED PROCEDURE name VIOLATES THE NESTING SQL RESTRICTION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Remove the failing statement from the named external function, trigger or the stored procedure.]]></programmersResponse>
		<sqlState>57053</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-747</code>
		<message><![CDATA[TABLE table-name IS NOT AVAILABLE UNTIL THE AUXILIARY TABLES AND INDEXES FOR ITS EXTERNALLY STORED COLUMNS HAVE BEEN CREATED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Use CREATE TABLESPACE to create a LOB table space. Use CREATE TABLE to create the auxiliary table for storing the column. Use CREATE INDEX to create an index on the auxiliary table. Resubmit the statement that failed.]]></programmersResponse>
		<sqlState>57054</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-748</code>
		<message><![CDATA[AN INDEX ALREADY EXISTS ON AUXILIARY TABLE table-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[An index already exists. Another index cannot be created.]]></programmersResponse>
		<sqlState>54042</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-750</code>
		<message><![CDATA[THE SOURCE TABLE source-name CANNOT BE RENAMED BECAUSE IT IS REFERENCED IN EXISTING VIEW, MATERIALIZED QUERY TABLE, OR TRIGGER DEFINITIONS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the source name to the name of an object that can be renamed and reissue the statement. Drop any triggers defined on the table before issuing the RENAME statement. These can be found by querying the system catalog: SELECT * FROM SYSIBM.SYSTRIGGERS WHERE TBNAME = 'source-name']]></programmersResponse>
		<sqlState>42986</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-751</code>
		<message><![CDATA[object-type object-name (SPECIFIC NAME specific name) ATTEMPTED TO EXECUTE AN SQL STATEMENT statement THAT IS NOT ALLOWED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Remove the unsupported statement from your stored procedure or user-defined function.
Remotely called stored procedures cannot execute embedded SQL Commit and/or Rollback statements unless:
 - The connection with the requester system uses one phase commit protocols
 - The requester system indicates that commits are allowed (via sending a DRDA RDBCMTOK=TRUE indication) when the stored procedure is called.
 - Note: For DB2 Connect requester systems, this requires that the client application must use Connect Type 1, or Remote Unit of Work connections. Connect Type 2 or Distributed Unit of Work connections will cause DB2 Connect to indicate that commits are not allowed, thus embedded SQL Commit and/or Rollback statements in a stored procedure will fail.

Any Commit or Rollback statements in the stored procedure must be removed, or the client application should be modified to establish an environment that allows the stored procedure to execute SQL Commit and/or Rollback statements.]]></programmersResponse>
		<sqlState>38003</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-752</code>
		<message><![CDATA[THE CONNECT STATEMENT IS INVALID BECAUSE THE PROCESS IS NOT IN THE CONNECTABLE STATE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Modify the application program to execute a commit or rollback operation prior to executing the CONNECT statement.]]></programmersResponse>
		<sqlState>0A001</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-763</code>
		<message><![CDATA[INVALID TABLE SPACE NAME table-space-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Either

Create the LOB table space in a non-workfile database. Create the table in a non-LOB table space. Create the auxiliary table in a LOB table space.]]></programmersResponse>
		<sqlState>560A1</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-764</code>
		<message><![CDATA[A LOB TABLE SPACE AND ITS ASSOCIATED BASE TABLE SPACE MUST BE IN THE SAME DATABASE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement to specify a LOB table space in the same database as the associated base table space.]]></programmersResponse>
		<sqlState>560A2</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-765</code>
		<message><![CDATA[TABLE IS NOT COMPATIBLE WITH DATABASE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If CREATE TABLE, either assign the table to an ROSHARE NONE database or create the table without a LOB column. If ALTER TABLE, redefine the column as a non-LOB column or move the table to an ROSHARE NONE database.]]></programmersResponse>
		<sqlState>560A3</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-766</code>
		<message><![CDATA[THE OBJECT OF A STATEMENT IS AN AUXILIARY TABLE FOR WHICH THE REQUESTED OPERATION IS NOT PERMITTED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement to specify the corresponding base table instead of the auxiliary table and resubmit the statement.]]></programmersResponse>
		<sqlState>560A4</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-767</code>
		<message><![CDATA[MISSING OR INVALID COLUMN SPECIFICATION FOR INDEX index-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the syntax of the CREATE INDEX statement.

To create an index on a non-auxiliary table, specify the columns on which the index is defined.
To create an index on an auxiliary table, do not specify the name of any column.]]></programmersResponse>
		<sqlState>42626</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-768</code>
		<message><![CDATA[AN AUXILIARY TABLE ALREADY EXISTS FOR THE SPECIFIED COLUMN OR PARTITION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Check that the correct table name, column name, and if applicable, partition number have been specified. If a different name is desired for the existing auxiliary table, the RENAME TABLE statement can be used to rename the auxiliary table.]]></programmersResponse>
		<sqlState>560A5</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-769</code>
		<message><![CDATA[SPECIFICATION OF CREATE AUX TABLE DOES NOT MATCH THE CHARACTERISTICS OF THE BASE TABLE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Check whether the name of the base table specified in the CREATE AUXILIARY TABLE statement is correct. If it is correct and the table is not partitioned, remove the PART clause from the statement. If it is correct and the table is partitioned, add the PART clause to the statement. If the table name is not correct, correct the name and also check that the correct column name is specified.]]></programmersResponse>
		<sqlState>53096</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-770</code>
		<message><![CDATA[TABLE table-name CANNOT HAVE A LOB COLUMN UNLESS IT ALSO HAS A ROWID COLUMN]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If creating a table with a LOB column, define a column with type ROWID in the same table. If using ALTER to add a LOB column to a table, first use ALTER to add a column with type ROWID to the table.]]></programmersResponse>
		<sqlState>560A6</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-771</code>
		<message><![CDATA[INVALID SPECIFICATION OF A ROWID COLUMN]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the syntax and resubmit the statement.]]></programmersResponse>
		<sqlState>428C7</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-797</code>
		<message><![CDATA[ATTEMPT to CREATE TRIGGER trigger-name WITH AN UNSUPPORTED TRIGGERED SQL STATEMENT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Check the triggered SQL statements in the trigger for any statement that is not listed above and remove it.]]></programmersResponse>
		<sqlState>42987</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-798</code>
		<message><![CDATA[YOU CANNOT INSERT A VALUE INTO A COLUMN THAT IS DEFINED WITH THE OPTION GENERATED ALWAYS COLUMN column-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Remove the column from the column-list or specify DEFAULT for the GENERATED ALWAYS column in the VALUES clause.
You may also use the OVERRIDING clause as a possible solution for this situation. See INSERT in DB2 SQL Reference for more information about the OVERRIDING USER VALUE clause.]]></programmersResponse>
		<sqlState>428C9</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-802</code>
		<message><![CDATA[EXCEPTION ERROR exception-type HAS OCCURRED DURING operation-type OPERATION ON data-type DATA, POSITION position-number]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine the SQL statement to see if the cause of the problem can be determined. The problem may be data-dependent, in which case it will be necessary to examine the data that was being processed at the time the error occurred.
If the arithmetic expression in error was within the SELECT list of the outer SELECT statement, then it is advisable to include an indicator variable for all expressions in the SELECT list. This allows processing to continue so that non-error column and expression values can be returned.
See the explanation of SQLCODE -405 for allowed ranges of numeric data types.
Problem Determination: A fixed point overflow can occur during any arithmetic operation on either INTEGER or SMALLINT fields.
A divide exception can occur on a decimal division operation when the quotient exceeds the specified data field size. A zero divide occurs on a division by zero.
An exponent overflow can occur when the result characteristic of any floating-point operation exceeds 127 and the result fraction is not zero, for example, the magnitude of the result exceeds approximately 7.2E+75.
A decimal overflow exception can occur under either of the following circumstances:
 - One or more non-zero digits are lost because the destination field in any decimal operation is too short to contain the result.
 - A Java stored procedure or user-defined function sets a decimal value in an output parameter that has a precision or scale too small for the value. operation-type is JAVA CONVERSION. data-type is DECIMAL. position-number indicates which parameter of the CALL statement or user-defined function invocation is in error.

Any of the exceptions/overflows can occur during the processing of a Built-In Function. If the operation-type is FUNCTION, then the error occurred while processing either an input, intermediate, or final value. The exception may occur because the value of a parameter is out of range.]]></programmersResponse>
		<sqlState>22012 if ZERO DIVIDE.

   22003 if other than ZERO DIVIDE.</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-803</code>
		<message><![CDATA[AN INSERTED OR UPDATED VALUE IS INVALID BECAUSE THE INDEX IN INDEX SPACE indexspace-name CONSTRAINS COLUMNS OF THE TABLE SO NO TWO ROWS CAN CONTAIN DUPLICATE VALUES IN THOSE COLUMNS. RID OF EXISTING ROW IS Xrid]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine the definitions for UNIQUE INDEX in the INDEX SPACE indexspace-name to determine the uniqueness constraint imposed. Please refer to SYSIBM.SYSINDEXES for the indexspace-name and the associated index-name.
For an UPDATE statement, verify that the specified operation is consistent with the uniqueness constraint. If this does not indicate the error, examine the object table to determine the cause of the problem.
For an INSERT statement, examine the object table to determine which values violate the uniqueness constraint. If the INSERT statement contains a subquery, match the contents of the table addressed by the subquery and the contents of the object table to determine the cause of the problem.
For a DELETE statement, examine the index key columns in the table that defines the index. These columns contain a foreign key, which when set NULL on a cascade delete from the object table, causes the duplicate values.]]></programmersResponse>
		<sqlState>23505</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-804</code>
		<message><![CDATA[AN ERROR WAS FOUND IN THE APPLICATION PROGRAM INPUT PARAMETERS FOR THE SQL STATEMENT, REASON reason]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine the application program for any of the errors noted under the explanation above. In general, the application programmer should not attempt to modify the output of the precompiler.]]></programmersResponse>
		<sqlState>07002</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-805</code>
		<message><![CDATA[DBRM OR PACKAGE NAME location-name.collection-id.dbrm-name.consistency -token NOT FOUND IN PLAN plan-name. REASON reason]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[]]></programmersResponse>
		<sqlState>51002</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-807</code>
		<message><![CDATA[ACCESS DENIED: PACKAGE package-name IS NOT ENABLED FOR ACCESS FROM connection-type connection-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[One of the following:
 - Rebind the package to enable it to execute with the required connection type and name.
 - Check the SYSPLSYSTEM or SYSPKSYSTEM catalog table to find a connection from which the package can be executed.
 - Correct the attach library.]]></programmersResponse>
		<sqlState>23509</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-808</code>
		<message><![CDATA[THE CONNECT STATEMENT IS NOT CONSISTENT WITH THE FIRST CONNECT STATEMENT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The probable cause of this error is that different programs in the application process were precompiled with different CONNECT options.
Ensure that the application process uses either type 1 or type 2 CONNECT statements and then resubmit the job. The type of CONNECT to be used is a precompiler option. The default is type 2 CONNECT.]]></programmersResponse>
		<sqlState>08001</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-811</code>
		<message><![CDATA[THE RESULT OF AN EMBEDDED SELECT STATEMENT OR A SUBSELECT IN THE SET CLAUSE OF AN UPDATE STATEMENT IS A TABLE OF MORE THAN ONE ROW, OR THE RESULT OF A SUBQUERY OF A BASIC PREDICATE IS MORE THAN ONE VALUE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Examine the syntax of the statement to ensure that it contains the proper condition specifications. If the statement syntax is correct, there might be a problem with the data that is causing more than one row or value to be returned when you do not expect it.]]></programmersResponse>
		<sqlState>21000</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-812</code>
		<message><![CDATA[THE SQL STATEMENT CANNOT BE PROCESSED BECAUSE A BLANK COLLECTION-ID WAS FOUND IN THE CURRENT PACKAGESET SPECIAL REGISTER WHILE TRYING TO FORM A QUALIFIED PACKAGE NAME FOR PROGRAM program-name.consistency-token USING PLAN plan-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Set the 'CURRENT PACKAGESET' special register to the desired 'collection-id' or have your system administrator check the plan's package list for correctness.]]></programmersResponse>
		<sqlState>22508</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-815</code>
		<message><![CDATA[A GROUP BY OR HAVING CLAUSE IS IMPLICITLY OR EXPLICITLY SPECIFIED IN A SUBSELECT OF A BASIC PREDICATE OR THE SET CLAUSE OF AN UPDATE STATEMENT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The implied function is not supported by DB2.
No coding workaround exists for the subselect. A GROUP BY or HAVING clause cannot be used within the subselect of a basic predicate because the subselect is allowed to return only a single value. For more information on basic predicates, refer to DB2 SQL Reference.]]></programmersResponse>
		<sqlState>42920</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-817</code>
		<message><![CDATA[THE SQL STATEMENT CANNOT BE EXECUTED BECAUSE THE STATEMENT WILL RESULT IN A PROHIBITED UPDATE OPERATION.]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If the application is running as an IMS inquiry-only transaction, see your IMS system programmer about changing the inquiry-only status of the transaction under which your application is running.
If the IMS or CICS application is attempting a remote update, either the application must be changed to run as a local application on the server DBMS, or the server DBMS must be upgraded to support two-phase commit.
If the application is attempting to update data at multiple locations, either the application must be changed, or all DBMSs involved must be upgraded to support two-phase commit.
If the error is due to an invalid statement during a trigger activation, contact your system administrator to correct the trigger definition.]]></programmersResponse>
		<sqlState>25000</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-818</code>
		<message><![CDATA[THE PRECOMPILER-GENERATED TIMESTAMP x IN THE LOAD MODULE IS DIFFERENT FROM THE BIND TIMESTAMP y BUILT FROM THE DBRM z]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[BIND the application again, using the DBRM for the application program that matches the object module.]]></programmersResponse>
		<sqlState>51003</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-819</code>
		<message><![CDATA[THE VIEW CANNOT BE PROCESSED BECAUSE THE LENGTH OF ITS PARSE TREE IN THE CATALOG IS ZERO]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[This is a system error. If you suspect an error in DB2, refer to Part 2 of DB2 Diagnosis Guide and Reference for information on identifying and reporting the problem.]]></programmersResponse>
		<sqlState>58004</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-820</code>
		<message><![CDATA[THE SQL STATEMENT CANNOT BE PROCESSED BECAUSE catalog-table CONTAINS A VALUE THAT IS NOT VALID IN THIS RELEASE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify that the statement refers to the intended tables or views and that the problem is the result of a fall back. If this is the case, the statement cannot be corrected because it depends on a function that is not supported in the current release. If the problem is not the result of a fallback, -820 is a system error. If you suspect an error in DB2, refer to Part 2 of DB2 Diagnosis Guide and Reference for information on identifying and reporting the problem.]]></programmersResponse>
		<sqlState>58004</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-822</code>
		<message><![CDATA[THE SQLDA CONTAINS AN INVALID DATA ADDRESS OR INDICATOR VARIABLE ADDRESS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the application program such that valid addresses are placed in SQLDA.]]></programmersResponse>
		<sqlState>51004</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-840</code>
		<message><![CDATA[TOO MANY ITEMS RETURNED IN A SELECT OR INSERT LIST]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Determine whether all the information is actually needed. (Note that the number of items returned by the select list * in the SQL statement SELECT * FROM A, B, C is the sum of the number of columns in all three tables.) If not, rewrite the SQL statement so that only the necessary items of information are returned. If so, break the SQL statement up into two or more statements, as required.]]></programmersResponse>
		<sqlState>54004</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-842</code>
		<message><![CDATA[A CONNECTION TO location-name ALREADY EXISTS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The correction depends on the error, as follows:
 - If the location name is not the intended name, correct it.
 - If SQLRULES(STD) is in effect and the CONNECT statement identifies an existing SQL connection, replace the CONNECT with SET CONNECTION or change the option to SQLRULES(DB2).
 - If the CONNECT statement identifies an existing private connection, destroy that connection (by using the RELEASE statement in a previous unit of work) before executing the CONNECT statement. If the SQL statements following the CONNECT can be executed using system-directed access, an alternative solution is to change the application to use that method.
 - If system-directed access cannot be used, destroy the conflicting SQL connection (by using the RELEASE statement in a previous unit of work) before executing the SQL statement that requires system-directed access. An alternative solution is to change the application so that only application-directed access is used.
 - Destroy the connection (by using the RELEASE statement in a previous unik of work) before executing the CONNECT statement which includes the USER/USING clause.

Correct the error in the application, rebind the plan or package, and resubmit the job.]]></programmersResponse>
		<sqlState>08002</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-843</code>
		<message><![CDATA[THE SET CONNECTION OR RELEASE STATEMENT MUST SPECIFY AN EXISTING CONNECTION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The correction depends on the error, as follows:
 - If the location name is not the intended name, correct it.
 - If the location name does not identify an existing SQL connection, replace the SET CONNECTION with a CONNECT statement.
 - If RELEASE CURRENT was executed in the unconnected state or the specified location name does not identify an existing SQL or DB2 private connection, delete the RELEASE statement.

Correct the error in the application, rebind, the plan and resubmit the job.]]></programmersResponse>
		<sqlState>08003</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-845</code>
		<message><![CDATA[A PREVIOUS VALUE EXPRESSION CANNOT BE USED BEFORE THE NEXT VALUE EXPRESSION GENERATES A VALUE IN THE CURRENT SESSION FOR SEQUENCE sequence-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Issue at least one NEXT VALUE expression for a sequence before issuing any PREVIOUS VALUE expression for the same sequence in a connection.]]></programmersResponse>
		<sqlState>51035</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-846</code>
		<message><![CDATA[INVALID SPECIFICATION OF AN IDENTITY COLUMN OR SEQUENCE OBJECT object_type object_name. REASON CODE = reason_code]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the syntax and resubmit the statement.]]></programmersResponse>
		<sqlState>42815</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-867</code>
		<message><![CDATA[INVALID SPECIFICATION OF A ROWID COLUMN]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the syntax and resubmit the statement.]]></programmersResponse>
		<sqlState>428C7</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-870</code>
		<message><![CDATA[THE NUMBER OF HOST VARIABLES IN THE STATEMENT IS NOT EQUAL TO THE NUMBER OF DESCRIPTORS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the application program. The most likely cause of this problem is a missing colon before a host variable.
Problem Determination: If the SQL statement is bound locally, descriptors are built by the DB2 precompiler. For a remote SQL statement, descriptors are built by DDF and are passed in the array SQLSTTVRB.]]></programmersResponse>
		<sqlState>58026</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-872</code>
		<message><![CDATA[A VALID CCSID HAS NOT YET BEEN SPECIFIED FOR THIS SUBSYSTEM]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Contact your system administrator to have the necessary CCSID defined for your system.]]></programmersResponse>
		<sqlState>51032</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-873</code>
		<message><![CDATA[THE STATEMENT REFERENCED DATA ENCODED WITH DIFFERENT ENCODING SCHEMES OR CCSIDS IN AN INVALID CONTEXT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the SQL statement.]]></programmersResponse>
		<sqlState>53090</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-874</code>
		<message><![CDATA[THE ENCODING SCHEME SPECIFIED FOR THE object-type MUST BE THE SAME AS THE CONTAINING TABLE SPACE OR OTHER PARAMETERS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the SQL statement.]]></programmersResponse>
		<sqlState>53091</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-875</code>
		<message><![CDATA[operand CANNOT BE USED WITH THE ASCII DATA REFERENCED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the SQL statement.]]></programmersResponse>
		<sqlState>42988</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-876</code>
		<message><![CDATA[object CANNOT BE CREATED, REASON reason]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the SQL statement for the object being created.]]></programmersResponse>
		<sqlState>53092</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-877</code>
		<message><![CDATA[CCSID ASCII OR CCSID UNICODE IS NOT ALLOWED FOR THIS DATABASE OR TABLE SPACE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Remove the CCSID ASCII or CCSID UNICODE clause from the statement.]]></programmersResponse>
		<sqlState>53093</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-878</code>
		<message><![CDATA[THE PLAN_TABLE USED FOR EXPLAIN CANNOT BE ASCII]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Drop the existing PLAN_TABLE, and recreate it with the EBCDIC encoding scheme or use Unicode.]]></programmersResponse>
		<sqlState>53094</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-879</code>
		<message><![CDATA[CREATE or ALTER STATEMENT FOR obj-name CANNOT DEFINE A COLUMN, DISTINCT TYPE, FUNCTION OR STORED PROCEDURE PARAMETER AS MIXED OR GRAPHIC WITH ENCODING SCHEME encoding-scheme]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Contact your system administrator to properly setup the installation options, or change the data types of the elements in columns in your CREATE or ALTER statement.]]></programmersResponse>
		<sqlState>53095</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-880</code>
		<message><![CDATA[SAVEPOINT savepoint-name DOES NOT EXIST OR IS INVALID IN THIS CONTEXT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement to use a valid savepoint name.]]></programmersResponse>
		<sqlState>3B001</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-881</code>
		<message><![CDATA[A SAVEPOINT WITH NAME savepoint-name ALREADY EXISTS, BUT THIS SAVEPOINT NAME CANNOT BE REUSED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement. Either use a different savepoint name, or omit the UNIQUE clause if the other savepoint was created without the UNIQUE clause and your intention is to reuse that savepoint name.]]></programmersResponse>
		<sqlState>3B501</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-882</code>
		<message><![CDATA[SAVEPOINT DOES NOT EXIST]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the application logic to either set a savepoint or to not attempt to rollback to a savepoint.]]></programmersResponse>
		<sqlState>3B502</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-900</code>
		<message><![CDATA[THE SQL STATEMENT CANNOT BE EXECUTED BECAUSE THE APPLICATION PROCESS IS NOT CONNECTED TO AN APPLICATION SERVER]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[It is possible that no response is required because checking for -900 is one way of detecting the unconnected state. If this is not the case, the logic of the application program must be changed. For additional information, see the description of the CONNECT statement in Chapter 5 of DB2 SQL Reference .]]></programmersResponse>
		<sqlState>08003</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-901</code>
		<message><![CDATA[UNSUCCESSFUL EXECUTION CAUSED BY A SYSTEM ERROR THAT DOES NOT PRECLUDE THE SUCCESSFUL EXECUTION OF SUBSEQUENT SQL STATEMENTS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If an abend occurred, notify the system programmer for analysis of the abend that caused this return code.
Even if an abend occurred, an application program receiving this return code can retry and is not prohibited from executing further SQL statements.]]></programmersResponse>
		<sqlState>58004</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-904</code>
		<message><![CDATA[UNSUCCESSFUL EXECUTION CAUSED BY AN UNAVAILABLE RESOURCE. REASON reason-code, TYPE OF RESOURCE resource-type, AND RESOURCE NAME resource-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify the identity of the resource that was not available. To determine why the resource was unavailable, refer to the specified reason-code.]]></programmersResponse>
		<sqlState>57011</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-905</code>
		<message><![CDATA[UNSUCCESSFUL EXECUTION DUE TO RESOURCE LIMIT BEING EXCEEDED, RESOURCE NAME = resource-name LIMIT = limit-amount1 CPU SECONDS (limit-amount2 SERVICE UNITS) DERIVED FROM limit-source]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Determine why this SQL statement or stored procedure took so long and take appropriate action. Consider simplifying the SQL statement, restructuring tables and indexes, or contacting the installation group responsible for maintaining the resource limit specification tables.
If the limit-source was a resource limit specification table or a system parameter, the application program that receives this return code can execute additional SQL statements.]]></programmersResponse>
		<sqlState>57014</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-906</code>
		<message><![CDATA[THE SQL STATEMENT CANNOT BE EXECUTED BECAUSE THIS FUNCTION IS DISABLED DUE TO A PRIOR ERROR]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[In general, an application program should terminate upon receipt of this return code. All subsequent attempts by the application to execute other SQL statements will also fail with the same return code. In the case of a DB2 CICS transaction, if the SQLERRP field in the SQLCA contains the module name DSNCEXT1, the transaction may issue a SYNCPOINT ROLLBACK and continue processing. If the transactions chooses to ROLLBACK and continue processing, it must be capable of correcting the situation that caused the create thread error to occur originally.]]></programmersResponse>
		<sqlState>51005</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-908</code>
		<message><![CDATA[bind-type ERROR USING auth-id AUTHORITY. BIND, REBIND OR AUTO-REBIND OPERATION IS NOT ALLOWED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If the indicated authorization id should be allowed to bind, change the entry in the active RLST table. If AUTO-REBIND operations are disabled, rebind the package before reexecuting the package.]]></programmersResponse>
		<sqlState>23510</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-909</code>
		<message><![CDATA[THE OBJECT HAS BEEN DELETED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The logic of the application program must be corrected such that it does not attempt to access or use an object after it has been dropped.
Dropping indexes within an application program is especially hazardous, because there is no way of determining whether or not the plan that has been generated for the application (by BIND or REBIND) actually uses a particular index for access to its object table.If the indicated authorization id should be allowed to bind, change the entry in the active RLST table. If AUTO-REBIND operations are disabled, rebind the package before reexecuting the package.]]></programmersResponse>
		<sqlState>57007</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-910</code>
		<message><![CDATA[THE SQL STATEMENT CANNOT ACCESS AN OBJECT ON WHICH A DROP OR ALTER IS PENDING]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[In the case of ALTER, the logic of the application program must be modified so that a COMMIT (or the IMS or CICS equivalent) is executed between the ALTER and the failing SQL statement.
For DROP, the logic of the application program should be modified such that there is no attempt to access an object after the DROP has been executed.
Note that DROP includes the case when rollback to a savepoint includes rolling back to a CREATE.]]></programmersResponse>
		<sqlState>57007</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-911</code>
		<message><![CDATA[THE CURRENT UNIT OF WORK HAS BEEN ROLLED BACK DUE TO DEADLOCK OR TIMEOUT. REASON reason-code, TYPE OF RESOURCE resource-type, AND RESOURCE NAME resource-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[A long-running application, or an application that is likely to encounter a deadlock, should (if possible) issue frequent COMMIT commands. This can lessen the possibility of a deadlock occurring. See message DSNT376I for other possible ways to avoid future deadlocks or timeouts. On receipt of the SQLCODE -911, the application should, in general, terminate.
For more information about how IMS, CICS, and TSO handle deadlocks, see Part 4 of DB2 Application Programming and SQL Guide.]]></programmersResponse>
		<sqlState>40001</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-913</code>
		<message><![CDATA[UNSUCCESSFUL EXECUTION CAUSED BY DEADLOCK OR TIMEOUT. REASON CODE reason-code, TYPE OF RESOURCE resource-type, AND RESOURCE NAME resource-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The application should either commit or roll back to the previous COMMIT. Then, generally, the application should terminate. See message DSNT376I for possible ways to avoid future deadlocks or timeouts.
For more information about how CICS and TSO handle deadlocks, see Part 4 of DB2 Application Programming and SQL Guide.]]></programmersResponse>
		<sqlState>57033</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-917</code>
		<message><![CDATA[BIND PACKAGE FAILED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the cause of the problem and try again.
Problem Determination: Inspect the SQLCODES issued for the SQL statements of the package.]]></programmersResponse>
		<sqlState>42969</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-918</code>
		<message><![CDATA[THE SQL STATEMENT CANNOT BE EXECUTED BECAUSE A CONNECTION HAS BEEN LOST]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[In general, an application program should issue a static ROLLBACK. Attempts by the application to issue SQL statements other than static ROLLBACK might fail. Once the static ROLLBACK is issued, the application can resume execution.
SQLERRP contains the name of the module that detected the previous failure and placed the application in the must-abort state.]]></programmersResponse>
		<sqlState>51021</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-919</code>
		<message><![CDATA[A ROLLBACK OPERATION IS REQUIRED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the application, function, or stored procedure, rebind it, and resubmit the job.
SQLERRP contains the name of the module that detected the previous failure and placed the application in the must-abort state.]]></programmersResponse>
		<sqlState>56045</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-922</code>
		<message><![CDATA[AUTHORIZATION FAILURE: error-type ERROR. REASON reason-code]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If error-type is user authorization:, the authorization-ID specified to DB2 through your attachment facility is not valid for DB2. See your system programmer or your CICS, IMS, or TSO system administrator.
If error-type is plan access, then the authorization ID associated with this connection is not authorized to use the specified plan name or the specified plan name does not exist. See your system administrator.
If error-type is duplicate exit, then you requested a duplicate exit.
If error-type is installation error, a connection or sign-on exit denied your request. See your system programmer.
If error-type is Connect, an SQL CONNECT request failed to connect to the local DB2 with USER/USING specified. See the reason code for a description of the failure. The application program has been palced in the connectable and unconneted state. The only SQL statements that can be successfully completed in this state are CONNET, COMMIT, ROLLBACK, and local SET statements. Any attempt to execute other SQL statements will result in an error (SQLCODE -900).
Look up the reason code in &quot;DB2 codes&quot; in topic 4.0 for further information.
Any attempts to issue SQL statements following the -922 SQLCODE when error-type is not Connect causes unpredictable results.]]></programmersResponse>
		<sqlState>42505</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-923</code>
		<message><![CDATA[CONNECTION NOT ESTABLISHED: DB2 condition REASON reason-code, TYPE resource-type, NAME resource-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If the connection failed because either DB2 or a required database, table space, table, or index was unavailable, wait until it is available before invoking the application again.
If allocation failed for an application plan, REBIND the plan to determine the problem. Error messages are produced explaining why the plan could not be allocated.
For other types of allocation errors, installation action might be required to correct the problem.
For CICS attachment failures, resolve the primary cause as noted by the reason code. Then restart the attachment.
Problem Determination: The reason-code, resource-type, and resource-name might not be available. If they are not available, nothing appears. If they are available, refer to DB2 codes for an explanation of the reason-code, resource-type, and resource-name.
Refer to message DSNT500I under DSNT... messages for an explanation of resource type and resource name. Refer to Table 3 in Appendix C, &quot;Problem determination&quot; in topic APPENDIX1.3 for an explanation of resource type codes. Any attempts to issue SQL statements after receiving SQLCODE -923 will cause unpredictable results.]]></programmersResponse>
		<sqlState>57015</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-924</code>
		<message><![CDATA[DB2 CONNECTION INTERNAL ERROR, function-code, return-code, reason-code]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Look up the abend 'reason-code' in DB2 codes for further information. The requested 'function-code' and 'return-code' may provide additional information. Any attempts to issue SQL statements following the SQLCODE -924 will cause unpredictable results.]]></programmersResponse>
		<sqlState>58006</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-925</code>
		<message><![CDATA[COMMIT NOT VALID IN IMS, CICS OR RRSAF ENVIRONMENT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The IMS, CICS or RRS protocols should be used to commit work in these environments.
If a stored procedure is being called from IMS or CICS, ensure that the stored procedure is not defined to perform a commit on return.]]></programmersResponse>
		<sqlState>2D521</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-926</code>
		<message><![CDATA[ROLLBACK NOT VALID IN IMS, CICS OR RRSAF ENVIRONMENT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The IMS, CICS or RRS protocols should be used to rollback work in these environments.]]></programmersResponse>
		<sqlState>2D521</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-927</code>
		<message><![CDATA[THE LANGUAGE INTERFACE (LI) WAS CALLED WHEN THE CONNECTING ENVIRONMENT WAS NOT ESTABLISHED. THE PROGRAM SHOULD BE INVOKED UNDER THE DSN COMMAND]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[In the TSO environment, DB2 application programs should be invoked under the RUN subcommand of the DSN command processor. In the IMS, CICS or CAF environment check that the application was link-edited with or is dynamically allocating the correct language interface module. The language interface modules required in each environment are as follows:
 - IMS: DFSLI000 CICS: DSNCLI CAF: DSNALI TSO: DSNELI

The DYNAM option can result in the incorrect language interface module being loaded at runtime.]]></programmersResponse>
		<sqlState>51006</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-929</code>
		<message><![CDATA[FAILURE IN A DATA CAPTURE EXIT: token]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[For documentation of the actions associated with this SQLCODE, refer to the Data Propagator (DPROP) publications.]]></programmersResponse>
		<sqlState>58002</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-939</code>
		<message><![CDATA[ROLLBACK REQUIRED DUE TO UNREQUESTED ROLLBACK OF A REMOTE SERVER]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Issue the appropriate (depending on the environment) request to cause a rollback. Re-establish any cursor positioning and continue the application with the first request that received the -939 SQLCODE.
SQLERRP contains the name of the module that detected the previous failure and placed the application in the must-abort state.]]></programmersResponse>
		<sqlState>51021</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-947</code>
		<message><![CDATA[THE SQL STATEMENT FAILED BECAUSE IT WILL CHANGE A TABLE DEFINED WITH DATA CAPTURE CHANGES, BUT THE DATA CANNOT BE PROPAGATED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Take one of the following actions:
 - Change the installation option to 1 (no propagation) or 3 (permit changes from any subsystem).
 - Change the application program that receives this SQLCODE so that it can be run in an IMS subsystem, and activate monitor trace class 6.

If the installation option is changed to 3, SQL changes to tables defined with DATA CAPTURE CHANGES are permitted from any subsystem, but they are not propagated unless the environment is set up for propagation.]]></programmersResponse>
		<sqlState>56038</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-948</code>
		<message><![CDATA[DISTRIBUTED OPERATION IS INVALID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[An application that performs local database updates before DDF is started cannot perform distributed operations within the same unit of work. The current unit of work must be terminated by a rollback operation and a new unit of work must be initiated before any SQL operations can be performed.
Restart the current unit of work.]]></programmersResponse>
		<sqlState>56062</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-950</code>
		<message><![CDATA[THE LOCATION NAME SPECIFIED IN THE CONNECT STATEMENT IS INVALID OR NOT LISTED IN THE COMMUNICATIONS DATABASE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If the location name is specified as the value of a host variable, ensure that the name is left justified in the host variable and, if necessary, padded on the right with blanks. If this is not the problem, either SYSIBM.LOCATIONS must be updated to include the specified name, or the specified name must be changed to match a name in SYSIBM.LOCATIONS.]]></programmersResponse>
		<sqlState>42705</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-952</code>
		<message><![CDATA[PROCESSING WAS INTERRUPTED BY A CANCEL REQUEST FROM A CLIENT PROGRAM]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[]]></programmersResponse>
		<sqlState>57014</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-981</code>
		<message><![CDATA[THE SQL STATEMENT FAILED BECAUSE THE RRSAF CONNECTION IS NOT IN A STATE THAT ALLOWS SQL OPERATIONS, REASON reason-code.]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[See reason-code in &quot;DB2 codes&quot; in topic 4.0 for an explanation of the problem. Correct the error in the application, REBIND, and run the application again.]]></programmersResponse>
		<sqlState>57015</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-989</code>
		<message><![CDATA[AFTER TRIGGER trigger-name ATTEMPTED TO MODIFY A ROW IN TABLE table-name THAT WAS INSERTED BY AN INSERT STATEMENT WITHIN A SELECT STATEMENT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Avoid using the INSERT statement within SELECT, or change the trigger so that it does not modify the table that is the target of the INSERT statement.]]></programmersResponse>
		<sqlState>560C3</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-991</code>
		<message><![CDATA[CALL ATTACH WAS UNABLE TO ESTABLISH AN IMPLICIT CONNECT OR OPEN TO DB2. RC1= rc1 RC2= rc2]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify that the application intended to use the call attachment facility (CAF) as the mechanism to connect to DB2. For functions or stored procedures running in the WLM-established stored procedure address space the application must be link-edited with or dynamically allocate the RRS attachment language interface module (DSNRLI), not CAF.]]></programmersResponse>
		<sqlState>57015</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-1403</code>
		<message><![CDATA[THE USERNAME AND/OR PASSWORD SUPPLIED IS INCORRECT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Supply the correct username and password combination.]]></programmersResponse>
		<sqlState>08004</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-1760</code>
		<message><![CDATA[CREATE PROCEDURE FOR procedure-name MUST HAVE VALID LANGUAGE AND EXTERNAL CLAUSES]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the CREATE statement to include the missing clause and reissue the statement.]]></programmersResponse>
		<sqlState>42601</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-2001</code>
		<message><![CDATA[THE NUMBER OF HOST VARIABLE PARAMETERS FOR A STORED PROCEDURE IS NOT EQUAL TO THE NUMBER OF EXPECTED HOST VARIABLE PARAMETERS. ACTUAL NUMBER sqldanum, EXPECTED NUMBER opnum]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If the SQL CALL statement is coded incorrectly, modify the SQL application to provide the correct number of parameters on the SQL CALL statement.]]></programmersResponse>
		<sqlState>53089</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-4302</code>
		<message><![CDATA[JAVA STORED PROCEDURE OR USER-DEFINED FUNCTION routine-name (SPECIFIC NAME specific-name) HAS EXITED WITH AN EXCEPTION exception-string]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The user-defined function or stored procedure probably needs to be corrected. See your database administrator, or the author of the routine to find out if the exception can be avoided, or if the user-defined function or stored procedure needs to be fixed before it can be used.]]></programmersResponse>
		<sqlState>38000</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-4700</code>
		<message><![CDATA[ATTEMPT TO USE NEW FUNCTION BEFORE NEW FUNCTION MODE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Either delay running your program until new-function mode has been enabled, or restrict your program to functions that are allowed before new-function mode is enabled.]]></programmersResponse>
		<sqlState>56038</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-4701</code>
		<message><![CDATA[THE NUMBER OF PARTITIONS, OR THE COMBINATION OF THE NUMBER OF TABLE SPACE PARTITIONS AND THE CORRESPONDING LENGTH OF THE PARTITIONING LIMIT KEY EXCEEDS THE SYSTEM LIMIT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Decrease the size of limit key or the number of table space partitions to satisfy the constraint.]]></programmersResponse>
		<sqlState>54054</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-4702</code>
		<message><![CDATA[THE MAXIMUM NUMBER OF ALTERS ALLOWED HAS BEEN EXCEEDED FOR object-type]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Run MODIFY to instruct DB2 that copies of a certain age will no longer be employed in recovery, and versions only used in those copies can be reused.]]></programmersResponse>
		<sqlState>54055</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-4703</code>
		<message><![CDATA[THE ALTER TABLE STATEMENT CANNOT BE EXECUTED BECAUSE COLUMN column-name IS MIXED DATA, OR THE DATA TYPE OR LENGTH SPECIFIED DOES NOT AGREE WITH THE EXISTING DATA TYPE OR LENGTH]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the SQL statement to specify a conversion that is supported.]]></programmersResponse>
		<sqlState>429BQ</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-5011</code>
		<message><![CDATA[HOST STRUCTURE ARRAY host-structure-array IS EITHER NOT DEFINED OR IS NOT USABLE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct any of the following, and precompile the program again. TBD Please comment]]></programmersResponse>
		<sqlState></sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-5012</code>
		<message><![CDATA[HOST VARIABLE host-variable IS NOT EXACT NUMERIC WITH SCALE ZERO]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the host variable to be an exact numeric with a scale of zero.]]></programmersResponse>
		<sqlState>42618</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20003</code>
		<message><![CDATA[GBPCACHE NONE CANNOT BE SPECIFIED FOR TABLESPACE OR INDEX IN GRECP]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Use the START DATABASE command to recover the table space or index from the GRECP then STOP the table space or index before reissuing the ALTER statement.]]></programmersResponse>
		<sqlState>560A7</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20004</code>
		<message><![CDATA[8K or 16K BUFFERPOOL PAGESIZE INVALID FOR A WORKFILE OBJECT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement to specify a 4K or 32K bufferpool pagesize.]]></programmersResponse>
		<sqlState>560A8</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20005</code>
		<message><![CDATA[THE INTERNAL ID LIMIT OF limit HAS BEEN EXCEEDED FOR OBJECT TYPE object-type]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Drop objects of object-type that are not being used, and retry the statement.]]></programmersResponse>
		<sqlState>54035</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20006</code>
		<message><![CDATA[LOBS CANNOT BE SPECIFIED AS PARAMETERS WHEN NO WLM ENVIRONMENT IS SPECIFIED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Either do not specify a LOB as a parameter, or specify a WLM ENVIRONMENT name rather than NO WLM ENVIRONMENT on your CREATE PROCEDURE statement.]]></programmersResponse>
		<sqlState>53097</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20008</code>
		<message><![CDATA[UNSUPPORTED OPTION keyword SPECIFIED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the syntax of the SQL statement to remove reference to the unsupported keyword. Refer to the DB2 SQL Reference for more information.]]></programmersResponse>
		<sqlState>560A9</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20058</code>
		<message><![CDATA[THE FULLSELECT SPECIFIED FOR MATERIALIZED QUERY TABLE table-name IS NOT VALID.]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the fullselect in the CREATE TABLE or ALTER TABLE statement so that it conforms to the rules listed above.]]></programmersResponse>
		<sqlState>428EC</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20070</code>
		<message><![CDATA[AUXILIARY TABLE table-name CANNOT BE CREATED BECAUSE COLUMN column-name IS NOT A LOB COLUMN]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the name of the column to correctly refer to a LOB column in the base table.]]></programmersResponse>
		<sqlState>53098</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20071</code>
		<message><![CDATA[WLM ENVIRONMENT NAME MUST BE SPECIFIED function-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Select a WLM ENVIRONMENT name and include it in the CREATE FUNCTION or CREATE PROCEDURE statement. Contact your system administrator to find out the names of the WLM environments that have been defined for your installation.]]></programmersResponse>
		<sqlState>53099</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20072</code>
		<message><![CDATA[csect-name bind-type bind-subtype ERROR USING auth-id AUTHORITY OPERATION IS NOT ALLOWED ON A TRIGGER PACKAGE package-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[A trigger package cannot be explicitly bound. A trigger package cannot be copied. To rebind a trigger package locally, the REBIND TRIGGER PACKAGE subcommand must be used. A trigger package cannot be rebound remotely. To drop a trigger package, the DROP TRIGGER statement must be used.]]></programmersResponse>
		<sqlState>56052</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20073</code>
		<message><![CDATA[THE FUNCTION function-name CANNOT BE ALTERED BECAUSE IT IS REFERENCED IN EXISTING VIEW OR MATERIALIZED QUERY TABLE DEFINITIONS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Drop the views that reference the function before issuing the ALTER FUNCTION statement. Drop the materialized query tables that reference the functions or alter the materialized query tables that reference the functions into base tables before issuing the ALTER FUNCTION statement.]]></programmersResponse>
		<sqlState>42927</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20074</code>
		<message><![CDATA[THE OBJECT object-name CANNOT BE CREATED BECAUSE THE FIRST THREE CHARACTERS ARE RESERVED FOR SYSTEM OBJECTS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Select a name that does not start with a reserved prefix.]]></programmersResponse>
		<sqlState>42939</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20091</code>
		<message><![CDATA[A VIEW NAME WAS SPECIFIED AFTER LIKE IN ADDITION TO THE INCLUDING IDENTITY COLUMN ATTRIBUTES CLAUSE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Remove the INCLUDING IDENTITY COLUMN ATTRIBUTES clause and resubmit the statement to copy the existing view definition without the identity column attributes.
In the case of DECLARE GLOBAL TEMPORARY TABLE, it is possible to get the identity column attributes for a column of a view using the AS subselect clause with INCLUDING IDENTITY COLUMN ATTRIBUTES instead. For example:
 - DECLARE GLOBAL TEMPORARY TABLE .... AS (SELECT * FROM view-name) DEFINITION ONLY INCLUDING IDENTITY COLUMN ATTRIBUTES]]></programmersResponse>
		<sqlState>560AD</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20092</code>
		<message><![CDATA[A VIEW WAS SPECIFIED FOR LIKE BUT IT INCLUDES A ROWID COLUMN]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Specify the name of a view that does not contain a ROWID column (or distinct type column for which the source type is ROWID), or specify the name of a table and resubmit the statement.]]></programmersResponse>
		<sqlState>560AE</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20093</code>
		<message><![CDATA[THE TABLE table-name CANNOT BE CONVERTED TO OR FROM A MATERIALIZED QUERY TABLE, OR THE MATERIALIZED QUERY TABLE PROPERTY CANNOT BE ALTERED. REASON CODE = reason-code.]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Depending on reason-code, take the following action:
 - reason-code Action
 - 2 There is no need to convert this table. No action is required.
 - 4 Drop any triggers, and try the ALTER TABLE statement again.
 - 5 Drop any check constraints, and try the ALTER TABLE statement again.
 - 6 Drop any unique constraint and unique indexes. Try the ALTER TABLE statement again.
 - 7 Drop the referential constraints, and try the ALTER TABLE statement again.
 - 8 Drop the materialized query table that references the table, and try ALTER TABLE statement again.
 - 9 A materialized query table cannot reference itself. Modify the fullselect to remove the direct or indirect reference to the table being altered.
 - 10 The operation is not allowed since the table is already a materialized query table.
 - 11 Modify the fullselect to include the correct number of columns in the select list.
 - 12 Modify the fullselect so that the result column data types exactly match the data types of the corresponding existing columns.
 - 13 Modify the fullselect so that the result column names exactly match the column names of the corresponding existing columns.
 - 14 The table cannot be converted to a materialized query table unless the the nullability characteristics can be matched. Create a new materialized query table instead.
 - 15 Perform the other table alterations in an ALTER TABLE statement that do not include the ADD MATERIALIZED QUERY clause.
 - 16 Either correct the table name to specify a materialized query table, or use the ALTER TABLE statement to convert the table to a materialized query table with the required properties.]]></programmersResponse>
		<sqlState>428EW</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20100</code>
		<message><![CDATA[AN ERROR OCCURRED WHEN BINDING A TRIGGERED SQL STATEMENT. INFORMATION RETURNED: SECTION NUMBER : section-number SQLCODE sqlerror, SQLSTATE sqlstate, AND MESSAGE TOKENS token-list]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Use the section number determine the failing triggered SQL statement. Refer to the explanation of the reported SQLCODE. Follow the action suggested by that message.]]></programmersResponse>
		<sqlState>56059</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20101</code>
		<message><![CDATA[THE FUNCTION function FAILED WITH REASON rc]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the condition described by the DB2 reason code.]]></programmersResponse>
		<sqlState>56060</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20102</code>
		<message><![CDATA[CREATE OR ALTER STATEMENT FOR ROUTINE routine-name SPECIFIED THE option OPTION WHICH IS NOT ALLOWED FOR THE TYPE OF ROUTINE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Remove the option from the statement and reissue the failing statement.]]></programmersResponse>
		<sqlState>42849</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20104</code>
		<message><![CDATA[AN ATTEMPT TO ALTER A CCSID FROM from-ccsid TO to-ccsid FAILED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The SQL REFERENCE contains a list of CCSIDs that can be specified on this statement. Only these CCSIDs can be altered, and then, only to the corresponding value listed in the table. Altering the CCSID of a database or table space to a value not listed in the table is not permitted.]]></programmersResponse>
		<sqlState>42856</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20106</code>
		<message><![CDATA[THE CCSID FOR TABLE SPACE OR DATABASE CANNOT BE CHANGED BECAUSE THE TABLE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[To alter the CCSID for the specified space, first drop any existing view or materialized query table definitions that refer to tables contained in the identified space and then reissue the ALTER statement.]]></programmersResponse>
		<sqlState>42945</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20107</code>
		<message><![CDATA[HOST VARIABLE OR PARAMETER NUMBER position-number CANNOT BE USED AS SPECIFIED BECAUSE REASON reason]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[This host variable or parameter requires machine instructions that are not available on this machine. These instructions must be available to DB2 to perform the requested operation. Run this statement on a machine that is capable of supporting the required operations. Contact your system administrator.]]></programmersResponse>
		<sqlState>53022</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20108</code>
		<message><![CDATA[A RESULT SET CONTAINS AN UNSUPPORTED DATA TYPE IN POSITION NUMBER position-number FOR CURSOR cursor-name OPENED BY STORED PROCEDURE procedure-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Modify the stored procedure at the server to return result sets that include only data types that are supported by the requester. You may also upgrade the level of code at the requester to one that supports the data type(s) that were returned by the server.]]></programmersResponse>
		<sqlState>56084</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20110</code>
		<message><![CDATA[CANNOT IMPLICITLY CONNECT TO A REMOTE SITE WITH A SAVEPOINT OUTSTANDING]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Either release the savepoint, or move the data.]]></programmersResponse>
		<sqlState>51036</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20111</code>
		<message><![CDATA[CANNOT ISSUE SAVEPOINT, RELEASE SAVEPOINT, ROLLBACK TO SAVEPOINT FROM A TRIGGER, FROM A USER-DEFINED FUNCTION, OR FROM A GLOBAL TRANSACTION]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the logic of the application program so that this error does not occur.]]></programmersResponse>
		<sqlState>3B503</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20123</code>
		<message><![CDATA[CALL TO STORED PROCEDURE procedure FAILED BECAUSE THE RESULT SET RETURNED FOR CURSOR cursor IS SCROLLABLE, BUT THE CURSOR IS NOT POSITIONED BEFORE THE FIRST ROW]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Modify the content of the stored procedure to ensure that the result set cursors are positioned before the first row before returning to the caller.]]></programmersResponse>
		<sqlState>560B1</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20124</code>
		<message><![CDATA[OPEN CURSOR cursor FAILED BECAUSE THE CURSOR IS SCROLLABLE BUT THE CLIENT DOES NOT SUPPORT THIS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Modify the definition of the curosr to not be scrollable.]]></programmersResponse>
		<sqlState>560B2</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20125</code>
		<message><![CDATA[CALL TO STORED PROCEDURE procedure FAILED BECAUSE THE RESULT SET FOR CURSOR cursor IS SCROLLABLE, BUT THE CLIENT DOES NOT SUPPORT THIS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Modify the content of stored procedure procedure to not define result set cursors as scrollable.]]></programmersResponse>
		<sqlState>560B3</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20127</code>
		<message><![CDATA[VALUE SPECIFIED ON FETCH STATEMENT FOR ABSOLUTE OR RELATIVE IS TOO LARGE FOR DRDA]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Modify the scroll specification on the FETCH statement.]]></programmersResponse>
		<sqlState>56051</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20129</code>
		<message><![CDATA[LOCAL SPECIAL REGISTER IS NOT VALID AS USED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Split the statement into multiple statements so that the local special registers are not referenced in a statement that assigns multiple values. Also be sure that a SET statement for a local special register does not use parenthesis on either side of the equal sign.]]></programmersResponse>
		<sqlState>560B5</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20142</code>
		<message><![CDATA[SEQUENCE sequence-name CANNOT BE USED AS SPECIFIED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Specify the name of a user-defined sequence object in this context.]]></programmersResponse>
		<sqlState>428FB</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20143</code>
		<message><![CDATA[THE ENCRYPTION OR DECRYPTION FUNCTION FAILED, BECAUSE THE ENCRYPTION PASSWORD VALUE IS NOT SET]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Issue the SET ENCRYPTION PASSWORD statement to set the ENCRYPTION PASSWORD value. The length of the PASSWORD must be a minimum of 6 bytes and a maximum of 127 bytes.]]></programmersResponse>
		<sqlState>51039</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20144</code>
		<message><![CDATA[THE ENCRYPTION IS INVALID BECAUSE THE LENGTH OF THE PASSWORD WAS LESS THAN 6 BYTES OR GREATER THAN 127 BYTES]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure that your password length is between 6 and 127 bytes in length.]]></programmersResponse>
		<sqlState>428FC</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20146</code>
		<message><![CDATA[THE DECRYPTION FAILED. THE DATA IS NOT ENCRYPTED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure that the data being decrypted has been encrypted using the ENCRYPT_TDES built-in-function.]]></programmersResponse>
		<sqlState>428FE</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20147</code>
		<message><![CDATA[THE ENCRYPTION FUNCTION FAILED. MULTIPLE PASS ENCRYPTION IS NOT SUPPORTED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure that the data that is being encrypted has not already been encrypted.]]></programmersResponse>
		<sqlState>55048</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20163</code>
		<message><![CDATA[HEXADECIMAL CONSTANT GX IS NOT ALLOWED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If your data is not graphic, use an X hexadecimal constant instead of a GX constant. If your MIXED DATA install option is set to NO, contact your system administrator to set up the installation options properly for use with the GX constant. If your application encoding scheme is UNICODE, use a UX hexadecimal constant instead of GX.]]></programmersResponse>
		<sqlState>560B9</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20165</code>
		<message><![CDATA[INSERT STATEMENT WITHIN A SELECT IS NOT ALLOWED IN THE CONTEXT IN WHICH IT WAS SPECIFIED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the statement so that the INSERT statement is used only in a SELECT statement that is a subselect or a SELECT INTO statement. Ensure that the INSERT statement in the FROM clause is the only table-spec in the FROM clause. Verify that NOT ATOMIC is not specified either as part of the INSERT statement, or, as part of the ATTRIBUTES clause of the PREPARE statement for a dynamic insert.]]></programmersResponse>
		<sqlState>428FL</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20166</code>
		<message><![CDATA[INSERT STATEMENT WITHIN A SELECT SPECIFIED A VIEW view-name WHICH IS NOT A SYMMETRIC VIEW]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Do not use the INSERT statement within a SELECT with the specified view.]]></programmersResponse>
		<sqlState>428FM</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20177</code>
		<message><![CDATA[SET DATA TYPE CLAUSE ON ALTER TABLE SPECIFIED FLOATING POINT, BUT THIS CHANGE IS DISALLOWED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the statement to specify a diferent compatible data type, and resubmit the statement.]]></programmersResponse>
		<sqlState>530A1</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20180</code>
		<message><![CDATA[COLUMN column-name IN TABLE table-name CANNOT BE ALTERED AS SPECIFIED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the name of the column to a column that can be altered, or drop and recreate the table with the necessary attributes.]]></programmersResponse>
		<sqlState>428FR</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20181</code>
		<message><![CDATA[COLUMN CANNOT BE ADDED TO INDEX index-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the statement to refer to an index that can have a column added to it.]]></programmersResponse>
		<sqlState>428FS</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20182</code>
		<message><![CDATA[PARTITIONING CLAUSE clause ON stmt-type STATEMENT FOR index-name IS NOT VALID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the name of the index to an index for which the values partitioning clause would be valid, and resubmit the statement.]]></programmersResponse>
		<sqlState>530A2</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20183</code>
		<message><![CDATA[THE PARITIONED, ADD PART, ADD PARTITIONING KEY, OR ALTER PART CLAUSE SPECIFIED ON CREATE OR ALTER FOR name IS NOT VALID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[]]></programmersResponse>
		<sqlState>428FT</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20185</code>
		<message><![CDATA[CURSOR cursor-name IS NOT DEFINED TO ACCESS ROWSETS, BUT A CLAUSE WAS SPECIFIED THAT IS VALID ONLY WITH ROWSET ACCESS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Remove the FOR n ROWS clause from the FETCH statement, or redefine the cursor for multiple row access with the WITH ROWSET POSITIONING clause on DECLARE CURSOR or PREPARE.]]></programmersResponse>
		<sqlState>24518</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20186</code>
		<message><![CDATA[A CLAUSE SPECIFIED FOR THE DYNAMIC SQL STATEMENT BEING PROCESSED IS NOT VALID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Remove the clause that was not valid in the context in which it was used.]]></programmersResponse>
		<sqlState>07501</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20200</code>
		<message><![CDATA[THE INSTALL OR REPLACE OF jar-id WITH URL url FAILED DUE TO REASON reason-code (reason-string).]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Reissue the install or replace jar procedure with a URL that identifies a valid jar file.]]></programmersResponse>
		<sqlState>46001</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20201</code>
		<message><![CDATA[THE INSTALL, REPLACE, OR REMOVE OF jar-name FAILED DUE TO REASON reason-code (reason-string)]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the jar identifier parameter and re-issue the request.]]></programmersResponse>
		<sqlState>46002</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20202</code>
		<message><![CDATA[THE REPLACE OR REMOVE OF jar-name FAILED AS class IS IN USE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure all routines referencing the classes being removed are dropped, and resubmit the replace or remove procedure.]]></programmersResponse>
		<sqlState>46003</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20203</code>
		<message><![CDATA[USER-DEFINED FUNCTION OR PROCEDURE name HAS A JAVA METHOD WITH AN INVALID SIGNATURE. THE ERROR IS AT OR NEAR PARAMETER number. THE SIGNATURE IS signature.]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Reissue the corresponding CREATE statement specifying parameters that match the Java method, or correct the specified procedure or function signature.]]></programmersResponse>
		<sqlState>46007</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20204</code>
		<message><![CDATA[THE USER-DEFINED FUNCTION OR PROCEDURE routine-name WAS UNABLE TO MAP TO A SINGLE JAVA METHOD]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The EXTERNAL NAME clause of the identified function or procedure must be altered to uniquely identify a valid Java method for the routine, or the Java class must be changed to have a single method with the specified or implicit signature.]]></programmersResponse>
		<sqlState>46008</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20207</code>
		<message><![CDATA[THE INSTALL OR REMOVE OF jar-name SPECIFIED THE USE OF A DEPLOYMENT DESCRIPTOR.]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Reissue the INSTALL_JAR or REMOVE_JAR procedure call with the DEPLOY or UNDEPLOY parameter set to zero.]]></programmersResponse>
		<sqlState>46501</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20210</code>
		<message><![CDATA[THE SQL STATEMENT CANNOT BE EXECUTED BECAUSE IT WAS AT A LEVEL THAT IS INCOMPATIBLE WITH THE CURRENT VALUE OF THE ENCODING]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[To correct the situation, you may:
 - Precompile the program again using the current precompiler and reissue the BIND command
 - Reissue the BIND command using ENCODING(EBCDIC) or ENCODING(ccsid) where ccsid represents the system EBCDIC CCSID.]]></programmersResponse>
		<sqlState>560B8</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20212</code>
		<message><![CDATA[USER-DEFINED ROUTINE name ENCOUNTERED AN EXCEPTION ATTEMPTING TO LOAD JAVA CLASS class-name FROM JAR jar-name. ORIGINAL EXCEPTION: exception-string.]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the condition reported by the exception-string.]]></programmersResponse>
		<sqlState>46103</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20213</code>
		<message><![CDATA[STORED PROCEDURE procedure-name HAS RETURNED A DYNAMIC RESULT SET OF AN INVALID CLASS. PARAMETER number IS NOT A DB2 RESULT SET]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Recreate the Java method to make returned DYNAMIC RESULT SET parameters be instances of the class produced by the DB2 for OS/390 JDBC driver (COM/ibm/db2os390/sqlj/jdbc/DB2SQLJResultSet).]]></programmersResponse>
		<sqlState>46502</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20223</code>
		<message><![CDATA[THE ENCRYPT_TDES OR DECRYPT FUNCTION FAILED. ENCRYPTION FACILITY NOT AVAILABLE return-code, reason-code]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If the encryption facility is not installed, then install it before using the ENCRYPT_TDES or DECRYPT functions. If the encryption facility is installed, then verify that it is working correctly. returncode and reason-code may give further information on the regarding why this message was issued. If the encryption facility is not installed, then install it before using the ENCRYPT_TDES or DECRYPT functions. If the encryption facility is installed, then verify that it is working correctly. returncode and reason-code may give further information on the regarding why this message was issued. Consult ICSF Application Programmers Guide, Appendix A, for the ICSF Return Code and ICSF Reason Codes for further information.]]></programmersResponse>
		<sqlState>560BF</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20227</code>
		<message><![CDATA[REQUIRED CLAUSE IS MISSING FOR ARGUMENT number OF expression]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the statement by providing the required clause for the argument.]]></programmersResponse>
		<sqlState>42633</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20232</code>
		<message><![CDATA[CHARACTER CONVERSION FROM CCSID from-ccsid TO to-ccsid FAILED WITH ERROR CODE error-code FOR TABLE dbid.obid COLUMN column-number REQUESTED BY csect-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If the error-code is 24 and the conversion request is correct, refer to the section entitled &quot;Character conversion&quot; of DB2 Installation Guide for information on how to add conversion support. For all the other error-codes, refer to Part 2 of DB2 Diagnosis Guide and Reference for information on identifying and reporting the problem.]]></programmersResponse>
		<sqlState>57017</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20235</code>
		<message><![CDATA[THE COLUMN column-name CANNOT BE ADDED OR ALTERED BECAUSE table-name IS A MATERIALIZED QUERY TABLE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Columns of materialized query tables cannot be added, altered, or dropped. Alter the materialized query table to become a regular table before adding, altering, or dropping a column.]]></programmersResponse>
		<sqlState>428FY</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20240</code>
		<message><![CDATA[INVALID SPECIFICATION OF A SECURITY LABEL COLUMN column-name REASON CODE reason-code]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the syntax and resubmit the statement.]]></programmersResponse>
		<sqlState>42963</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20248</code>
		<message><![CDATA[ATTEMPTED TO EXPLAIN A CACHED STATEMENT WITH STMTID OR STMTTOKEN ID-token BUT THE REQUIRED EXPLAIN INFORMATION IS NOT ACCESSIBLE.]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Perform the following steps:
 - If the EXPLAIN statement specifies an ID or token (STMTCACHE STMID or STMTCACHE STMTOKEN):
 - Check if dynamic statement caching is on and if the statement ID or token is correct. The EXPLAIN statement cannot be executed if dynamic statement caching has never been turned on.
 - Re-execute (or re-prepare) the statement to be explained, find the updated statement ID or token, and explain it again.
 - Correct the authorization problem and re-execute the EXPLAIN statement.
 - If the EXPLAIN statement specifies all cached statements (STMTCACHE ALL):
 - Check that dynamic statement caching is on.
 - Re-execute (or re-prepare) the statements to be explained
 - Correct any authorization problems, and re-execute the EXPLAIN statement.]]></programmersResponse>
		<sqlState>26501</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20249</code>
		<message><![CDATA[THE PACKAGE package-name NEEDS TO BE REBOUND IN ORDER TO BE SUCCESSFULLY EXECUTED (token)]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Take the appropriate action as explained in the explanation.]]></programmersResponse>
		<sqlState>560C5</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20252</code>
		<message><![CDATA[DIAGNOSTICS AREA FULL. NO MORE ERRORS CAN BE RECORDED FOR THE NOT ATOMIC STATEMENT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Analyze the warning and error conditions using the GET DIAGNOSTICS statement. Determine how to change the statement to eliminate or reduce the number of warnings and errors. It is up to the programmer to determine if a ROLLBACK or COMMIT should be issued for this message. Either is appropriate depending on the appliction logic.]]></programmersResponse>
		<sqlState>429BI</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20264</code>
		<message><![CDATA[FOR TABLE table-name, primary-auth-id WITH SECURITY LABEL primary-auth-id-seclabel, IS NOT AUTHORIZED TO PERFORM operation ON A ROW WITH SECURITY LABEL row-seclabel. THE RECORD IDENTIFIER (RID) OF THIS ROW IS rid-number.]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[If this user is authorized to perform this operation, ensure that this user has been properly defined to MLS. If the row data needs to be viewed, use DSN1PRINT.
In the case of a view or cursor, where the primary authorization ID is able to access more rows then it can update or delete, you can add the WHERE clause to limit the rows accessed, based on the security label of the primary authorization ID. The security label can be retrieved using GETVARIABLE(SYSIBM.SECLABEL).]]></programmersResponse>
		<sqlState>42512</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20265</code>
		<message><![CDATA[SECURITY LABEL IS reason FOR primary-auth-id]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure the value that was specified for the security label of this user is a valid security label. If it is valid, then this error may be caused if the SECLABEL class in the Security Server has not been activated.]]></programmersResponse>
		<sqlState>42501</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20266</code>
		<message><![CDATA[ALTER VIEW FOR view-name FAILED INFORMATION RETURNED: SQLCODE: sqlcode, SQLSTATE: sqlstate, MESSAGE TOKENS token-list]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[]]></programmersResponse>
		<sqlState>560C7</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20281</code>
		<message><![CDATA[primary-auth-id DOES NOT HAVE THE MLS WRITE-DOWN PRIVILEGE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure that the user has the MLS write-down privilege when write-down is in effect.]]></programmersResponse>
		<sqlState>42513</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20283</code>
		<message><![CDATA[A DYNAMIC CREATE STATEMENT CANNOT BE PROCESSED WHEN THE VALUE OF CURRENT SCHEMA DIFFERS FROM CURRENT SQLID]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the value of the CURRENT SCHEMA special register to be the same as the content of the CURRENT SQLID special register.]]></programmersResponse>
		<sqlState>429BN</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20286</code>
		<message><![CDATA[DB2 CONVERTED STRING token-type token FROM from-ccsid TO to-ccsid, AND RESULTED IN SUBSTITUTION CHARACTERS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure that the data that is provided to DB2 can be converted from from-ccsid to to-ccsid without data loss.]]></programmersResponse>
		<sqlState>428GB</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-20289</code>
		<message><![CDATA[INVALID STRING LENGTH UNIT unit SPECIFIED FOR FUNCTION function-name]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Change the invocation of the function to remove the invalid string length unit or change it to a valid unit for the data type being processed.]]></programmersResponse>
		<sqlState>428GC</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30000</code>
		<message><![CDATA[EXECUTION FAILED DUE TO A DISTRIBUTION PROTOCOL ERROR THAT WILL NOT AFFECT THE SUCCESSFUL EXECUTION OF SUBSEQUENT COMMANDS OR SQL STATEMENTS: REASON reason-code (sub-code)]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Notify the DBA for assistance in analysis of the SQL statement which yielded this SQLCODE.
Problem Determination: The 'reason-code' identifies the DDM code point which represents the DDM reply message received from the remote server in response to the attempt to execute the SQL statement. These represent internal errors detected at the remote server or possibly, by the local DB2 functions.
The 'reason-code' value is the two-byte hexadecimal code point for the DDM reply message that represents the error and is one of the following:
 - X'1254' - CMDCHKRM X'220A' - DSCINVRM X'220E' - DTAMCHRM X'1245' - PRCCNVRM X'2202' - QRYNOPRM X'220F' - QRYPOPRM X'2207' - RDBACCRM X'2204' - RDBNACRM X'124C' - SYNTAXRM

A two-byte 'sub-code' accompanies 'reason-codes' X'220A' (DSCINVRM), X'1245' (PRCCNVRM), and X'124C' (SYNTAXRM). In all other cases, the 'sub-code' is zero.
The 'sub-code' when nonzero, consists of two bytes such that the high-order byte indicates the site at which the error was detected. This is X'01' if the error was detected by the local DB2; it is X'02' if the error was detected by the remote server. The low-order byte is dependent on the 'reason-code' as follows:
 - Description Error Code (DSCERRCD) if 'reason-code' = X'220A' (DSCINVRM).
 - Syntax Error Code (SYNERRCD) if 'reason-code' = X'124C' SYNTAXRM).
 - Conversational Protocol Error Code (PRCCVNCD) if 'reason-code' = X'1245' (PRCCNVRM).

Refer to the IBM Distributed Data Management (DDM) Reference Guide for a detailed discussion of the semantics of the DDM terms DSCERRCD, SYNERRCD, and PRCCNVCD.]]></programmersResponse>
		<sqlState>58008</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30002</code>
		<message><![CDATA[THE SQL STATEMENT CANNOT BE EXECUTED DUE TO A PRIOR CONDITION IN A CHAIN OF STATEMENTS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The statement must be sent again as a separate request.]]></programmersResponse>
		<sqlState>57057</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30005</code>
		<message><![CDATA[EXECUTION FAILED BECAUSE FUNCTION NOT SUPPORTED BY THE SERVER: LOCATION location PRODUCT ID pppvvrr REASON reason-code (sub-code)]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Notify the DBA for assistance in analyzing the SQL statement that prompted this SQL code.
Problem Determination: location identifies the name of the server that could not support hte required database protocals to perform the requested function. The product identifier is in the form pppvvrrm. It is an eight-byte field with alphanumeric characters, and identifies the product that could not support the function. ppp identifies the specific database product. vv identifies the product version. rr identifies the product release level. m identifies the product modification level.
Possible values for pppvvrrm:
 - ppp DSN for z/OS, ARI for VM/VSE, SQL for Unix/Windows/NT, QSQ for iSeries, and JCC for Java
 - vv Version number
 - rr Release level
 - m Modification level

To correct the problem, first identify the function that is not supported. To determine what function was not supported, and why, refer to the reason-code that was specified. Here are the possible values for reason-code, and the functions that they correspond to:
 - 0010 LONG_STMTS
 - 0010 LONG255_IDS
 - 0030 EXTENDED_DESCRIBE
 - 0040 EXTENDED_DIAGNOSTICS
 - 0050 KEEP_DYNAMIC
 - 0060 MULTI_ROW_FETCH
 - 0070 MULTI_ROW_INSERT
 - 0080 SQL_CANCEL
 - 0090 SCROLLABLE_CURSORS
 - 0100 CURSOR_ATTRIBUTES
 - 0110 MONITORING
 - 0120 SELECT_WITH_INSERT
 - 0130 DATA_ENCRYPTION
 - 0140 PACKAGE_PATH

Lastly, you may use the sub-code value to further identify the problem. When non-zero, the sub-code consists of a one-byte code to indicate how the error was detected in the network:
 - If '01'x, then the local DB2 that is acting as the requester detected the error. The LOCATION and PRDID identify the server in error.
 - If '02'x, then the server detected the error. The LOCATION and PRDID identify the location and level of the local DB2 server.
 - If '03'x, then an intermediate server (hop site) detected the error. The error, the LOCATION, and PRDID identify the server in error.
 - If '04'x, then an intermediate server (hop site) detected the error. The error, the LOCATION, and PRDID identify the server in error.]]></programmersResponse>
		<sqlState>56072</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30020</code>
		<message><![CDATA[EXECUTION FAILED DUE TO A DISTRIBUTION PROTOCOL ERROR THAT CAUSED DEALLOCATION OF THE CONVERSATION: REASON &lt;reason-code (sub-code)&gt;]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The connection to the server has been broken, and the server has, therefore, rolled back the unit of work. In this case, the only SQL statement that may be successfully executed is ROLLBACK. However, if the requester detects this error on a COMMIT, then it is unknown whether the unit of work was committed or rolled back at the server.]]></programmersResponse>
		<sqlState>58009</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30021</code>
		<message><![CDATA[EXECUTION FAILED DUE TO A DISTRIBUTION PROTOCOL ERROR THAT WILL AFFECT THE SUCCESSFUL EXECUTION OF SUBSEQUENT COMMANDS OR SQL STATEMENTS: MANAGER manager AT LEVEL level NOT SUPPORTED ERROR]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Notify the system programmer for analysis of the condition that caused this SQLCODE.]]></programmersResponse>
		<sqlState>58010</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30025</code>
		<message><![CDATA[EXECUTION FAILED BECAUSE FUNCTION IS NOT SUPPORTED BY THE SERVER WHICH CAUSED TERMINATION OF THE CONNECTION: LOCATION location PRODUCT ID pppvvrr REASON reason-code (sub-code)]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Notify the DBA for assistance in analyzing the SQL statement that prompted this SQL code.
Problem Determination: location identifies the name of the server that could not support hte required database protocals to perform the requested function. The product identifier is in the form pppvvrrm. It is an eight-byte field with alphanumeric characters, and identifies the product that could not support the function. ppp identifies the specific database product. vv identifies the product version. rr identifies the product release level. m identifies the product modification level.
Possible values for pppvvrrm:
 - ppp DSN for z/OS, ARI for VM/VSE, SQL for Unix/Windows/NT, QSQ for iSeries, and JCC for Java
 - vv Version number
 - rr Release level
 - m Modification level

To correct the problem, first identify the function that is not supported. To determine what function was not supported, and why, refer to the reason-code that was specified. Here are the possible values for reason-code, and the functions that they correspond to:
 - 0010 LONG_STMTS
 - 0010 LONG255_IDS
 - 0030 EXTENDED_DESCRIBE
 - 0040 EXTENDED_DIAGNOSTICS
 - 0050 KEEP_DYNAMIC
 - 0060 MULTI_ROW_FETCH
 - 0070 MULTI_ROW_INSERT
 - 0080 SQL_CANCEL
 - 0090 SCROLLABLE_CURSORS
 - 0100 CURSOR_ATTRIBUTES
 - 0110 MONITORING
 - 0120 SELECT_WITH_INSERT
 - 0130 DATA_ENCRYPTION
 - 0140 PACKAGE_PATH

Lastly, you may use the sub-code value to further identify the problem. When non-zero, the sub-code consists of a one-byte code to indicate how the error was detected in the network:
 - If '01'x, then the local DB2 that is acting as the requester detected the error. The LOCATION and PRDID identify the server in error.
 - If '02'x, then the server detected the error. The LOCATION and PRDID identify the location and level of the local DB2 server.
 - If '03'x, then an intermediate server (hop site) detected the error. The error, the LOCATION, and PRDID identify the server in error.
 - If '04'x, then an intermediate server (hop site) detected the error. The error, the LOCATION, and PRDID identify the server in error.]]></programmersResponse>
		<sqlState>56073</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30030</code>
		<message><![CDATA[COMMIT REQUEST WAS UNSUCCESSFUL, A DISTRIBUTION PROTOCOL VIOLATION HAS BEEN DETECTED, THE CONVERSATION HAS BEEN DEALLOCATED. ORIGINAL SQLCODE=original-sqlcode AND ORIGINAL SQLSTATE=original-sqlstate]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Notify the system programmer for assistance in analyzing the trace data that was generated.]]></programmersResponse>
		<sqlState>58013</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30040</code>
		<message><![CDATA[EXECUTION FAILED DUE TO UNAVAILABLE RESOURCES THAT WILL NOT AFFECT THE SUCCESSFUL EXECUTION OF SUBSEQUENT COMMANDS OR SQL STATEMENTS. REASON reason-code TYPE OF RESOURCE resource-type RESOURCE NAME resource-name PRODUCT ID pppvvrrm RDBNAME rdbname]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify the identify of the resource that was not available. The reason the resource is unavailable is identified by the reason-code.
Collect the following diagnostic items to help determine the cause of the unavailable resource.

Console output from the system identified by RDBNAME, and a listing of SYSLOG data set for the period of time spanning the failure.
Information described for the reason code received.]]></programmersResponse>
		<sqlState>57012</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30041</code>
		<message><![CDATA[EXECUTION FAILED DUE TO UNAVAILABLE RESOURCES THAT WILL AFFECT THE SUCCESSFUL EXECUTION OF SUBSEQUENT COMMANDS AND SQL STATEMENTS. REASON &lt;reason-code&gt; TYPE OF RESOURCE &lt;resource-type&gt; RESOURCE NAME &lt;resource-name&gt; PRODUCT ID &lt;pppvvrrm&gt; RDBNAME &lt;rdbname&gt;]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Verify the identity of the resource that was not available. The reason the resource is unavailable is identified by the reason-code.
Collect the following diagnostic items to help determine the cause of the unavailable resource.

Console output from the system identified by RDBNAME, and a listing of SYSLOG data set for the period of time spanning the failure.
Information described for the &lt;reason-code&gt; received.]]></programmersResponse>
		<sqlState>57013</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30050</code>
		<message><![CDATA[&lt;command-or-SQL-statement-type COMMAND OR SQL STATEMENT INVALID WHILE BIND PROCESS IN PROGRESS]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure the remote bind has completed before attempting to execute an SQL statement or process a remote command. COMMIT and ROLLBACK will terminate the bind processing.]]></programmersResponse>
		<sqlState>58011</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30051</code>
		<message><![CDATA[BIND PROCESS WITH SPECIFIED PACKAGE NAME AND CONSISTENCY TOKEN NOT ACTIVE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure that the server processing the bind request was not abending when this request was being processed, or that the package name hasn't changed before terminating the remote bind package request.]]></programmersResponse>
		<sqlState>58012</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30052</code>
		<message><![CDATA[PROGRAM PREPARATION ASSUMPTIONS ARE INCORRECT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The creation of the package following this error is dependent on the package creation options specified at begin bind time.]]></programmersResponse>
		<sqlState>42932</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30053</code>
		<message><![CDATA[OWNER AUTHORIZATION FAILURE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the authorization problem and reissue the request.]]></programmersResponse>
		<sqlState>42506</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30060</code>
		<message><![CDATA[RDB AUTHORIZATION FAILURE]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the authorization problem and resubmit the job.]]></programmersResponse>
		<sqlState>08004</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30061</code>
		<message><![CDATA[RDB NOT FOUND]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure the RDB name was correctly specified and resubmit the job.]]></programmersResponse>
		<sqlState>08004</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30070</code>
		<message><![CDATA[command COMMAND NOT SUPPORTED ERROR]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure the proper command was issued.]]></programmersResponse>
		<sqlState>58014</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30071</code>
		<message><![CDATA[object-type OBJECT NOT SUPPORTED ERROR]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Ensure the object has been correctly specified and resubmit the job or reissue the command.]]></programmersResponse>
		<sqlState>58015</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30072</code>
		<message><![CDATA[parameter subcode PARAMETER NOT SUPPORTED ERROR]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The connection to the server has been broken, and the server has therefore rolled back the unit of work. In this case, the only SQL statement that may be successfully executed is ROLLBACK. However, if the requester detects this error on a COMMIT, then it is unknown whether the unit of work was committed or rolled back at the server.]]></programmersResponse>
		<sqlState>58016</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30073</code>
		<message><![CDATA[parameter subcode PARAMETER VALUE NOT SUPPORTED ERROR]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The connection to the server was broken, and the server rolled back the unit of work. The only SQL statement that can be successfully executed is ROLLBACK. However, if the requester detects this error on a COMMIT, then it is unknown whether the unit of work was committed or rolled back at the server.]]></programmersResponse>
		<sqlState>58017</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30074</code>
		<message><![CDATA[REPLY MESSAGE WITH codepoint (svrcod) NOT SUPPORTED ERROR]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The cause of this error may be a mismatch in source and targe manager levels or might be an internal error.]]></programmersResponse>
		<sqlState>58018</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30080</code>
		<message><![CDATA[COMMUNICATION ERROR code (subcode)]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Review the diagnostic information described in VTAM for MVS/ESA Programming for LU 6.2 for the particular LU6.2 return codes. Consult with a communications expert to determine the cause of the communication failure.]]></programmersResponse>
		<sqlState>08001</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30081</code>
		<message><![CDATA[prot COMMUNICATION ERROR DETECTED. API=api, LOCATION=loc, FUNCTION=func, ERROR CODES=rc1 rc2 rc3]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Consult with a communications expert to determine the cause of the communication failure.]]></programmersResponse>
		<sqlState>08001</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30082</code>
		<message><![CDATA[CONNECTION FAILED FOR SECURITY REASON reason-code (reason-string)]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[DB2 uses the communications database (CDB) to control network security functions. Make the appropriate changes to the CDB to correct the security failure.]]></programmersResponse>
		<sqlState>08001</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30090</code>
		<message><![CDATA[REMOTE OPERATION INVALID FOR APPLICATION EXECUTION ENVIRONMENT]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Do not attempt to update data or issue dynamic commits or rollbacks from IMS or CICS applications that are accessing remote data.]]></programmersResponse>
		<sqlState>25000</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30104</code>
		<message><![CDATA[ERROR IN BIND OPTION option AND BIND VALUE value.]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The BIND or REBIND command failed. Examine the command options and values, determine the error, and resubmit the command.]]></programmersResponse>
		<sqlState>56095</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30105</code>
		<message><![CDATA[BIND OPTION option1 IS NOT ALLOWED WITH BIND OPTION option2]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[The BIND or REBIND command failed. Examine the command options, determine the cause of the conflict, and resubmit the command.]]></programmersResponse>
		<sqlState>56096</sqlState>
	</ReturnCodes>
	<ReturnCodes>
		<code>-30106</code>
		<message><![CDATA[INVALID INPUT DATA DETECTED FOR A MULTIPLE ROW INSERT OPERATION. INSERT PROCESSING IS TERMINATED]]></message>
		<explanation><![CDATA[]]></explanation>
		<systemAction><![CDATA[]]></systemAction>
		<programmersResponse><![CDATA[Correct the row containing the invalid input data and submit the multiple-row INSERT statement again for the rows that did not get inserted.]]></programmersResponse>
		<sqlState>22527</sqlState>
	</ReturnCodes>
</EdtHelp>
